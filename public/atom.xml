<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Loire&#39;s Blog</title>
  
  <subtitle>技术笔记与知识管理</subtitle>
  <link href="https://ccloire.com/atom.xml" rel="self"/>
  
  <link href="https://ccloire.com/"/>
  <updated>2025-08-12T05:00:06.993Z</updated>
  <id>https://ccloire.com/</id>
  
  <author>
    <name>Loire</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C&amp;C++基础语法-命令行参数</title>
    <link href="https://ccloire.com/2025/08/12/C++%E5%90%88%E9%9B%86/C&amp;C++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/"/>
    <id>https://ccloire.com/2025/08/12/C++%E5%90%88%E9%9B%86/C&amp;C++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/</id>
    <published>2025-08-12T04:53:23.000Z</published>
    <updated>2025-08-12T05:00:06.993Z</updated>
    
    <content type="html"><![CDATA[<h2id="第一部分什么是命令行参数-command-line-arguments">第一部分：什么是命令行参数(Command-line Arguments)？</h2><p><strong>命令行参数</strong>是在您从终端（命令行界面）启动一个程序时，跟在程序名称后面传递给该程序的一系列字符串。它们是<strong>一种让用户从外部控制程序行为、向程序传递初始数据的主要方式</strong>。</p><p>想象一下，程序本身是一个函数，而命令行参数就是您传递给这个函数的“参数”。</p><p><strong>一个直观的例子：</strong> 当您在 Linux 终端输入这个命令时：<code>ls -l /home</code></p><ul><li><code>ls</code>：这是您要执行的<strong>程序名</strong>。</li><li><code>-l</code>：这是传递给 <code>ls</code>程序的<strong>第一个参数</strong>。它告诉 <code>ls</code>程序使用“长列表格式”来显示文件。</li><li><code>/home</code>：这是传递给 <code>ls</code>程序的<strong>第二个参数</strong>。它告诉 <code>ls</code> 程序去列出<code>/home</code> 目录下的内容。</li></ul><p>通过 <code>-l</code> 和 <code>/home</code> 这两个参数，我们控制了<code>ls</code> 程序的输出格式和目标路径，而无需修改 <code>ls</code>程序本身的任何代码。</p><h3 id="在-cc-中如何接收命令行参数">在 C/C++ 中如何接收命令行参数？</h3><p>C/C++ 程序通过 <code>main</code>函数的两个特殊形参来接收命令行参数：<code>argc</code> 和<code>argv</code>。</p><p>C++</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>int argc</code> (Argument Count):这是一个整数，表示<strong>命令行参数的总数量</strong>。这个计数<strong>总是至少为1</strong>，因为它把程序自身的名字也算作第一个参数。</li><li><code>char *argv[]</code> (Argument Vector):这是一个“指向字符指针的指针数组”，简单理解就是一个<strong>字符串数组</strong>。它包含了所有的参数字符串。<ul><li><code>argv[0]</code>：永远是<strong>程序本身的名字</strong>（例如<code>"./my_program"</code>）。</li><li><code>argv[1]</code>：是第一个实际的参数（例如<code>"-l"</code>）。</li><li><code>argv[2]</code>：是第二个实际的参数（例如<code>"/home"</code>）。</li><li>...</li><li><code>argv[argc-1]</code>：是最后一个参数。</li><li><code>argv[argc]</code>：标准保证这一定是一个<strong>空指针(<code>nullptr</code>)</strong>，可以作为数组结束的标记。</li></ul></li></ul><p><strong>示例代码：</strong> 将以下代码保存为<code>test.cpp</code>，并编译 (<code>g++ test.cpp -o test</code>)。</p><p>C++</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;收到了 &quot; &lt;&lt; argc &lt;&lt; &quot; 个命令行参数。&quot; &lt;&lt; std::endl;</span><br><span class="line">    for (int i = 0; i &lt; argc; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;argv[&quot; &lt;&lt; i &lt;&lt; &quot;]: &quot; &lt;&lt; argv[i] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，在终端中这样运行它： <code>./test hello world 123</code></p><p><strong>输出将会是：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">收到了 4 个命令行参数。</span><br><span class="line">argv[0]: ./test</span><br><span class="line">argv[1]: hello</span><br><span class="line">argv[2]: world</span><br><span class="line">argv[3]: 123</span><br></pre></td></tr></table></figure><hr /><h2id="第二部分命令行参数和环境变量存放在哪里">第二部分：命令行参数和环境变量存放在哪里？</h2><p>这是个更深入的问题，它涉及到程序启动时内存的布局。</p><p>回顾我们之前讨论的内存布局图。命令行参数和环境变量都存放在一个非常特殊的位置：<strong>位于栈的顶部之上，属于进程用户空间的最高地址部分。</strong></p><p><strong>详细的启动过程和内存存放：</strong></p><ol type="1"><li><strong>准备阶段 (在 Shell 中)</strong>：当您在 shell (如<code>bash</code>) 中输入 <code>./test hello</code> 并按回车时，shell进程会负责启动 <code>test</code> 程序。shell本身知道您给出的参数（<code>"hello"</code>）和它自己的所有环境变量（如<code>PATH</code>, <code>HOME</code> 等）。</li><li><strong><code>execve</code> 系统调用</strong>：shell 通过<code>execve()</code> 这个系统调用来加载并执行 <code>test</code>程序。这是最关键的一步。内核（Kernel）在处理 <code>execve</code>时，会为 <code>test</code> 程序创建一个全新的虚拟地址空间。</li><li><strong>内核填充数据</strong>：在新的地址空间准备好后，内核会做一件事：<strong>将命令行参数和环境变量的字符串本身，从旧的shell 进程复制到新进程用户空间地址的最高处</strong>。</li><li><strong>设置栈顶</strong>：紧接着在这些字符串的下方，内核会构建<code>argv</code> 和 <code>envp</code> (环境变量指针数组)这两个指针数组。数组中的每个指针分别指向刚才复制过来的那些字符串。<code>argc</code>的值也会被放在这里。</li><li><strong>启动程序</strong>：最后，内核将栈指针 <code>esp</code>设置在这些数据结构的下方，然后将CPU的控制权交给程序的启动代码（<code>_start</code>），<code>_start</code>会进一步调用我们的 <code>main</code> 函数，并将 <code>argc</code> 和<code>argv</code> 的地址作为参数传递给 <code>main</code>。</li></ol><p><strong>内存布局示意图（用户空间顶部）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+ 0xC0000000 (内核空间起始)</span><br><span class="line">|                       |</span><br><span class="line">| &quot;HOME=/home/user&quot;     | \</span><br><span class="line">| &quot;USER=myuser&quot;         |  &gt; 环境变量字符串</span><br><span class="line">| ...                   | /</span><br><span class="line">+-----------------------+</span><br><span class="line">| &quot;world&quot;               | \</span><br><span class="line">| &quot;hello&quot;               |  &gt; 命令行参数字符串</span><br><span class="line">| &quot;./test&quot;              | /</span><br><span class="line">+-----------------------+</span><br><span class="line">| nullptr               | \</span><br><span class="line">| 指向 &quot;HOME=...&quot; 的指针 |  &gt; envp[] 数组</span><br><span class="line">| 指向 &quot;USER=...&quot; 的指针 | /</span><br><span class="line">+-----------------------+</span><br><span class="line">| nullptr               | \</span><br><span class="line">| 指向 &quot;world&quot; 的指针   |  &gt; argv[] 数组</span><br><span class="line">| 指向 &quot;hello&quot; 的指针   |</span><br><span class="line">| 指向 &quot;./test&quot; 的指针  | /</span><br><span class="line">+-----------------------+</span><br><span class="line">| 4 (argc 的值)         |</span><br><span class="line">+-----------------------+ &lt;--- 栈顶指针(esp)初始指向这里</span><br><span class="line">|                       |</span><br><span class="line">|          栈           |</span><br><span class="line">|  (Stack grows down)   | &lt;--- 后续函数调用将在这里创建栈帧</span><br><span class="line">|           |           |</span><br><span class="line">|           v           |</span><br><span class="line">|                       |</span><br><span class="line">+-----------------------+</span><br><span class="line">|          ...          | (mmap, heap, .data, etc.)</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ul><li><strong>什么是命令行参数？</strong><ul><li>它们是在程序启动时从外部传入的字符串，用于控制程序行为。</li><li>在C/C++中通过 <code>main(int argc, char *argv[])</code>接收。<code>argc</code> 是数量，<code>argv</code> 是字符串数组。</li></ul></li><li><strong>它们存放在哪里？</strong><ul><li>存放在<strong>进程用户空间内存的最高地址区域，位于栈的初始位置之上</strong>。</li><li>这个区域由<strong>操作系统内核</strong>在程序启动执行<code>execve</code>系统调用时负责创建和填充，然后将指向这片区域的指针作为参数传递给程序的<code>main</code> 函数。</li></ul></li></ul><h1 id="命令行参数作用">命令行参数作用</h1><p>命令行参数的用处极其广泛，可以说是程序员和系统管理员工具箱中最重要的工具之一。</p><p>它的核心作用是：<strong>让一个程序变得灵活、可配置、可自动化，而无需修改程序源代码。</strong></p><p>想象一下，如果没有命令行参数，<code>ls</code>命令就只能用一种方式列出文件；<code>cp</code>命令就不知道要拷贝哪个文件到哪里。我们必须为每一种细微的需求都编写一个全新的程序。而命令行参数允许我们用同一个程序来处理无数种不同的场景。</p><p>下面通过几个真实且经典的例子，来展示它的具体用途。</p><h2id="指定输入和输出告诉程序对谁操作结果放哪">指定输入和输出：告诉程序“对谁操作，结果放哪”</h2><p>这是最基本、最常见的用途。</p><p><strong>示例：<code>g++</code> 编译器</strong></p><p>Bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -o my_app</span><br></pre></td></tr></table></figure><ul><li><strong><code>g++</code></strong>: 要执行的程序（C++编译器）。</li><li><strong><code>main.cpp</code></strong>:第一个参数，是<strong>输入文件</strong>。它告诉 <code>g++</code>去编译哪个源代码文件。</li><li><strong><code>-o</code></strong>:第二个参数，是一个<strong>选项（Flag）</strong>，意思是“我要指定输出文件名”。</li><li><strong><code>my_app</code></strong>: 第三个参数，是 <code>-o</code>选项的值，即<strong>输出文件</strong>的名字。</li></ul><p><strong>作用</strong>：如果没有这些参数，<code>g++</code>根本不知道要编译哪个文件，编译后的程序叫什么名字。通过参数，我们精确地指导了编译器的工作流程。</p><h2 id="控制程序行为告诉程序怎么做">控制程序行为：告诉程序“怎么做”</h2><p>通过“选项”或“标志”（Flags），我们可以像拨动开关一样改变程序的内部行为。</p><p><strong>示例：<code>ls</code> (列出目录内容)</strong></p><ul><li><p>只执行 <code>ls</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">Desktop  Documents  Downloads  Music  Pictures</span><br></pre></td></tr></table></figure></li><li><p>加入参数 <code>ls -l</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">drwxr-xr-x 2 user user 4096 Aug 10 10:20 Desktop</span><br><span class="line">drwxr-xr-x 3 user user 4096 Aug 11 15:30 Documents</span><br><span class="line">drwxr-xr-x 2 user user 4096 Jul 29 09:00 Downloads</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>-l</code> 参数就像一个开关，它告诉<code>ls</code>：“请使用**长列表格式（longformat）**显示，包含权限、所有者、大小等详细信息。”</p></li><li><p>加入更多参数 <code>ls -l -a -h</code> (或者合并为<code>ls -lah</code>):</p><ul><li><code>-a</code> (all): “请显示所有文件，<strong>包括以<code>.</code> 开头的隐藏文件</strong>。”</li><li><code>-h</code> (human-readable):“请以<strong>人类易读的格式</strong>（如 <code>4.0K</code>,<code>1.2M</code>）显示文件大小，而不是显示字节数。”</li></ul></li></ul><p><strong>作用</strong>：同一个 <code>ls</code>程序，通过不同的参数组合，可以实现完全不同的显示效果，满足了用户从“快速浏览”到“详细审查”的各种需求。</p><h2id="提供运行所需的数据给程序提供原料">提供运行所需的数据：给程序“提供原料”</h2><p>有些程序必须要有外部数据才能运行。</p><p><strong>示例：<code>ping</code> (网络诊断工具)</strong></p><p>Bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 5 google.com</span><br></pre></td></tr></table></figure><ul><li><strong><code>ping</code></strong>: 程序名。</li><li><strong><code>-c 5</code></strong>: 一个带值的选项，告诉<code>ping</code> 程序：“总共只<strong>发送 5 次</strong>请求就停止。”(<code>c</code> 代表 count)。</li><li><strong><code>google.com</code></strong>: 一个必需的参数，告诉<code>ping</code> 程序：“你要测试的目标主机是 **<ahref="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=google.com**。”">https://www.google.com/url?sa=E&amp;source=gmail&amp;q=google.com**。”</a></li></ul><p><strong>作用</strong>：如果没有 <code>google.com</code>这个参数，<code>ping</code> 程序就失去了目标，完全无法工作。而<code>-c 5</code> 则进一步配置了它的具体行为。</p><h2id="实现自动化和批处理让程序在脚本中被重复使用">实现自动化和批处理：让程序在脚本中被重复使用</h2><p>这是命令行参数最强大的地方，是所有自动化脚本（Shell Script, PythonScript 等）的基石。</p><p><strong>场景</strong>：假设你写了一个 Python 脚本<code>process_log.py</code>，用来分析服务器日志文件并生成报告。</p><p><strong>不使用参数的糟糕做法</strong>：每次要分析不同的日志文件（比如 <code>nginx.log</code> 或<code>apache.log</code>），你都必须<strong>打开<code>process_log.py</code>文件，手动修改里面的文件名变量</strong>。这非常低效且容易出错。</p><p><strong>使用命令行参数的优秀做法</strong>：你的脚本可以这样写（伪代码）：</p><p>Python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># process_log.py</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"># 从命令行参数获取文件名</span><br><span class="line">log_file_name = sys.argv[1] </span><br><span class="line">output_report_name = sys.argv[2]</span><br><span class="line"></span><br><span class="line"># ... 打开 log_file_name 进行分析 ...</span><br><span class="line"># ... 将结果保存到 output_report_name ...</span><br></pre></td></tr></table></figure><p>现在，你可以这样使用它，并且可以轻松地把它写进一个自动执行的脚本里：</p><p>Bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 分析昨天的 Nginx 日志，并生成报告</span><br><span class="line">python process_log.py /var/log/nginx/access.log.1 report-yesterday.txt</span><br><span class="line"></span><br><span class="line"># 分析上周的 Apache 日志</span><br><span class="line">python process_log.py /var/log/apache/access.log.week32 report-week32.txt</span><br></pre></td></tr></table></figure><p><strong>作用</strong>：你的 <code>process_log.py</code>脚本变成了一个通用的、可重用的工具。你可以用它处理任何日志文件，而无需改动代码。这使得自动化任务（例如：每天凌晨自动分析前一天的日志）成为可能。</p><h2id="执行不同的子命令组织复杂的功能">执行不同的子命令：组织复杂的功能</h2><p>现代很多复杂的工具（如 <code>git</code>, <code>docker</code>,<code>kubectl</code>）都使用这种模式。第一个参数不是选项或文件名，而是一个<strong>子命令</strong>。</p><p><strong>示例：<code>git</code> (版本控制系统)</strong></p><ul><li><code>git clone &lt;url&gt;</code>: <code>clone</code>是一个子命令，告诉 <code>git</code> 你要做“克隆仓库”这个大类操作。</li><li><code>git pull</code>: <code>pull</code>是另一个子命令，执行“拉取更新”操作。</li><li><code>git commit -m "Fix bug"</code>: <code>commit</code>是子命令，执行“提交更改”操作。而 <code>-m "..."</code> 则是专属于<code>commit</code> 子命令的参数。</li></ul><p><strong>作用</strong>：这种方式极大地增强了程序的组织性，使得一个程序（<code>git</code>）可以包含成百上千种功能，但用户可以通过逻辑清晰的子命令来使用它们。</p><h2 id="总结-1">总结</h2><p>总而言之，命令行参数是连接用户和程序的桥梁，它的用处体现在：</p><ul><li><strong>灵活性(Flexibility)</strong>：让同一个程序适应不同场景。</li><li><strong>自动化(Automation)</strong>：让程序可以被脚本调用，实现无人值守的任务。</li><li><strong>可组合性 (Composability)</strong>ta：可以将多个简单的命令行工具组合起来，完成复杂的任务（这是 Unix/Linux的核心哲学）。</li><li><strong>效率(Efficiency)</strong>：对于熟练的用户来说，使用命令行参数远比在图形界面中点击鼠标要快得多。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2
id=&quot;第一部分什么是命令行参数-command-line-arguments&quot;&gt;第一部分：什么是命令行参数
(Command-line Arguments)？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;命令行参数&lt;/strong&gt;是在您从终端（命令行界面）启动一个程序时，跟</summary>
      
    
    
    
    
    <category term="C++" scheme="https://ccloire.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C&amp;C++基础语法--静态变量总结</title>
    <link href="https://ccloire.com/2025/08/11/C++%E5%90%88%E9%9B%86/C&amp;C++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://ccloire.com/2025/08/11/C++%E5%90%88%E9%9B%86/C&amp;C++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%80%BB%E7%BB%93/</id>
    <published>2025-08-11T06:24:03.000Z</published>
    <updated>2025-08-11T13:00:48.934Z</updated>
    
    <content type="html"><![CDATA[<p><code>static</code>是一个非常关键的修饰符，但它的含义并不是单一的，而是根据其使用的<strong>位置</strong>而有所不同。它的核心作用可以归结为两点：<strong>改变变量的生命周期</strong>和<strong>改变变量或函数的链接属性（可见性）</strong>。</p><p>我们将分三个场景来讨论 <code>static</code>：</p><ol type="1"><li>在函数内部使用（局部静态变量）</li><li>在函数外部使用（全局静态变量/函数）</li><li>在类（Class）内部使用（静态成员变量/函数）</li></ol><h2id="在函数内部局部静态变量-local-static-variable">在函数内部：局部静态变量(Local Static Variable)</h2><p>当 <code>static</code>用于修饰函数内部的局部变量时，它彻底改变了这个变量的“生存方式”。</p><p><strong>核心作用：延长生命周期。</strong></p><p>一个普通的局部变量是存放在<strong>栈</strong>上的，它会随着函数的调用而被创建，随着函数的返回而被销毁。而一个局部静态变量则完全不同。</p><p><strong>特性：</strong></p><ol type="1"><li><strong>存储位置</strong>：它不再存储于栈上，而是和全局变量一样，存放在程序的<strong>静态存储区</strong>（<code>.data</code>或 <code>.bss</code> 段）。</li><li><strong>生命周期</strong>：它的生命周期是<strong>整个程序的运行期间</strong>，而不是函数的调用期间。从程序开始到结束，它都存在。</li><li><strong>初始化</strong>：它只在程序<strong>第一次执行到其声明语句时被初始化，且仅初始化一次</strong>。后续再次调用该函数时，会跳过这条初始化语句，变量会保持上一次调用结束时的值。</li><li><strong>作用域</strong>：尽管它的生命周期是全局的，但它的<strong>作用域（可见性）</strong>仍然是局部的，即只能在声明它的那个函数内部访问。</li></ol><p><strong>经典示例：函数调用计数器</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">count_calls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>; <span class="comment">// 局部静态变量</span></span><br><span class="line">    counter++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;这个函数被调用了 &quot;</span> &lt;&lt; counter &lt;&lt; <span class="string">&quot; 次。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">count_calls</span>(); <span class="comment">// 第一次调用，counter 从 0 变成 1。输出 &quot;1 次&quot;</span></span><br><span class="line">    <span class="built_in">count_calls</span>(); <span class="comment">// 第二次调用，counter 从 1 变成 2。输出 &quot;2 次&quot;</span></span><br><span class="line">    <span class="built_in">count_calls</span>(); <span class="comment">// 第三次调用，counter 从 2 变成 3。输出 &quot;3 次&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>counter</code> 变量就像是<code>count_calls</code>函数的“私人记忆”，函数调用结束后它的值依然保留，但外界完全无法访问它。</p><hr /><h2id="在函数外部全局静态变量与静态函数">在函数外部：全局静态变量与静态函数</h2><p>当 <code>static</code>用于修饰函数外部的全局变量或函数时，它的作用与生命周期无关（因为全局变量的生命周期本来就是整个程序），而是改变了它们的<strong>链接属性（Linkage）</strong>。</p><p><strong>核心作用：限制作用域于当前文件。</strong></p><p>默认情况下，一个全局变量或函数具有<strong>外部链接 (ExternalLinkage)</strong>，这意味着其他源文件（<code>.cpp</code>文件）可以通过<code>extern</code> 关键字来访问和使用它。</p><p>而一旦用 <code>static</code>修饰，它的链接属性就从“外部”变成了<strong>内部链接 (InternalLinkage)</strong>。</p><p><strong>特性：</strong></p><ol type="1"><li><strong>可见性</strong>：被 <code>static</code>修饰的全局变量或函数，其可见性被限制在<strong>它所定义的那个源文件内部</strong>。其他源文件即使使用<code>extern</code> 也无法访问到它。</li><li><strong>避免命名冲突</strong>：这是它最重要的用途。当你在一个大型项目中，不同的人在不同的源文件中可能无意中定义了同名的全局变量或辅助函数。如果这些变量/函数不是<code>static</code>的，链接器（Linker）在链接时就会发现多个同名符号，导致“多重定义(multiple definition)”错误。而将它们声明为<code>static</code>，就相当于告诉链接器：“这个变量/函数是本文件私有的，与其他文件无关”，从而避免了冲突。</li></ol><p><strong>示例：</strong></p><p><strong><code>file1.cpp</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个变量只在 file1.cpp 中可见</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> secret_counter = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数也只在 file1.cpp 中可见</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">private_helper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;这是 file1 的私有辅助函数。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">public_function_in_file1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    secret_counter++;</span><br><span class="line">    <span class="built_in">private_helper</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;file1 中的 secret_counter 是: &quot;</span> &lt;&lt; secret_counter &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>file2.cpp</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个函数，它在别处定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">public_function_in_file1</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试访问 file1 中的静态变量和函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> secret_counter; <span class="comment">// 尝试引用</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">private_helper</span><span class="params">()</span></span>; <span class="comment">// 尝试引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">public_function_in_file1</span>(); <span class="comment">// 这个调用是合法的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这两行会导致链接错误 (Linker Error)!</span></span><br><span class="line">    <span class="comment">// 因为 secret_counter 和 private_helper 对 file2.cpp 是不可见的。</span></span><br><span class="line">    <span class="comment">// secret_counter = 0; </span></span><br><span class="line">    <span class="comment">// private_helper();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>现代C++建议</strong>：对于限制文件作用域的需求，更推荐使用<strong>匿名命名空间(Anonymous Namespace)</strong>，它提供了比 <code>static</code>更强大和清晰的功能。</p><hr /><h2id="在类class内部静态成员变量与静态成员函数">在类（Class）内部：静态成员变量与静态成员函数</h2><p>当 <code>static</code>用于类的成员时，它表示这个成员<strong>属于类本身，而不是类的任何一个具体实例（对象）</strong>。</p><h3 id="静态成员变量-static-member-variable">静态成员变量 (Static MemberVariable)</h3><ol type="1"><li><strong>共享性</strong>：一个类的所有对象<strong>共享同一个</strong>静态成员变量。无论创建了多少个对象，内存中该变量都只有一个副本。</li><li><strong>存储位置</strong>：它同样存储在静态存储区（<code>.data</code>或 <code>.bss</code>），不占用任何对象的内存空间。</li><li><strong>生命周期</strong>：它的生命周期也是整个程序的运行期间。</li><li><strong>初始化</strong>：必须在<strong>类定义的外部</strong>进行定义和初始化（<code>const static int</code>等少数情况除外）。</li></ol><p><strong>示例：对象计数器</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Apple</span>() &#123;</span><br><span class="line">        apple_count++; <span class="comment">// 每创建一个对象，计数器加1</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Apple</span>() &#123;</span><br><span class="line">        apple_count--; <span class="comment">// 每销毁一个对象，计数器减1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前有 &quot;</span> &lt;&lt; apple_count &lt;&lt; <span class="string">&quot; 个苹果对象。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> apple_count; <span class="comment">// 声明一个静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类外对静态成员变量进行定义和初始化</span></span><br><span class="line"><span class="type">int</span> Apple::apple_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Apple a1;</span><br><span class="line">    a<span class="number">1.</span><span class="built_in">print_count</span>(); <span class="comment">// 输出：当前有 1 个苹果对象。</span></span><br><span class="line"></span><br><span class="line">    Apple a2;</span><br><span class="line">    a<span class="number">1.</span><span class="built_in">print_count</span>(); <span class="comment">// a1 和 a2 共享同一个 apple_count，输出：当前有 2 个苹果对象。</span></span><br><span class="line">    a<span class="number">2.</span><span class="built_in">print_count</span>(); <span class="comment">// 输出：当前有 2 个苹果对象。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态成员函数-static-member-function">静态成员函数 (Static MemberFunction)</h3><ol type="1"><li><strong>归属性</strong>：它也属于类本身，不属于任何特定对象。</li><li><strong>调用方式</strong>：可以通过类名直接调用(<code>ClassName::function()</code>)，也可以通过对象调用(<code>object.function()</code>)，但本质上没有区别。</li><li><strong>无 <code>this</code>指针</strong>：这是最关键的区别。静态成员函数内部<strong>没有<code>this</code>指针</strong>，因此它<strong>不能</strong>直接访问非静态成员（变量或函数），因为它不知道该访问“哪个对象”的成员。它只能访问静态成员。</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MathHelper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="comment">// 静态成员函数</span></span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 它不能访问非静态成员，比如：</span></span><br><span class="line">    <span class="comment">// void set_value(int v) &#123; non_static_value = v; &#125;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// int non_static_value;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接通过类名调用，无需创建对象</span></span><br><span class="line">    <span class="type">int</span> sum = MathHelper::<span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// sum is 8</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 + 3 = &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><table><thead><tr><th>使用位置</th><th>主要作用</th><th>核心特性</th></tr></thead><tbody><tr><td><strong>函数内部</strong></td><td><strong>延长生命周期</strong></td><td>值在函数调用间保持，只初始化一次，作用域仍为局部。</td></tr><tr><td><strong>函数外部（全局）</strong></td><td><strong>限制链接属性（可见性）</strong></td><td>变量或函数只在当前源文件内可见，避免命名冲突。</td></tr><tr><td><strong>类内部</strong></td><td><strong>属于类，而非对象</strong></td><td>所有对象共享同一份数据（静态变量），函数无<code>this</code>指针（静态函数）。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;static&lt;/code&gt;
是一个非常关键的修饰符，但它的含义并不是单一的，而是根据其使用的&lt;strong&gt;位置&lt;/strong&gt;而有所不同。它的核心作用可以归结为两点：&lt;strong&gt;改变变量的生命周期&lt;/strong&gt;和&lt;strong&gt;改变变量或函数的链接</summary>
      
    
    
    
    
    <category term="C++" scheme="https://ccloire.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++初——1内存空间与编译原理</title>
    <link href="https://ccloire.com/2025/08/07/C++%E5%90%88%E9%9B%86/C++%E5%88%9D%E7%BA%A7%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <id>https://ccloire.com/2025/08/07/C++%E5%90%88%E9%9B%86/C++%E5%88%9D%E7%BA%A7%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</id>
    <published>2025-08-07T14:13:10.000Z</published>
    <updated>2025-08-18T12:30:02.517Z</updated>
    
    <content type="html"><![CDATA[<p>PS：本C++进阶讲解基于x86 32位linux环境</p><h2id="进程的虚拟地址空间内存划分和布局">进程的虚拟地址空间内存划分和布局</h2><p>我们知道，任何的编程语言，在编译文件后都会产生的两种东西是指令和数据，并以可执行文件.exe的形式存储在磁盘里，而每次运行可执行文件时，都需要将磁盘上的.exe加载到内存当中，由CPU读取指令并对数据进行操作。</p><p>那么磁盘上的文件加载到内存（虚拟内存，而非直接加载到物理内存）后，如何为数据分配内存空间，内存空间的结构划分是什么样的，就需要我们详细了解。</p><p>首先，linux系统给每一个进程会分配一个<spanclass="math inline">\(2^{32}\)</span> =4G大小的一块虚拟内存空间（地址范围0x00000000<code>~~</code>0xFFFFFFFF）。这块空间大体分为两部分：用户空间（0x00000000<code>~~</code>0xC0000000，占3G）和内核空间（0xC0000001<code>~~</code>0xFFFFFFF，占1G）。</p><p>内存空间按地址从低到高，更具体的划分如下：</p><ol type="1"><li><p>整个内存空间的前一小块（0x00000000—0x08048000，低地址空间）是不可访问的，这片区域在现代linux操作系统中是故意留空用于保护的，防止空指针访问导致程序崩溃。如果程序试图访问虚拟地址0x0，cpu的内存管理单元会查询页表中的虚拟到物理地址映射，发现这片低地址并没有有效映射（无对应物理地址），就会发生异常中断程序进程。</p><p>e.g.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">strlen</span>(p); <span class="comment">//strlen()函数试图访问指针p指向的内存空间存放的数据并求长度，但p是指向nullptr也即零地址0x0的空指针，程序运行时会报错。</span></span><br><span class="line"><span class="type">char</span> *src = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(p,src); <span class="comment">//同理，strcpy()函数试图访问空指针src指向的内存，将其存放的数据拷贝给p，将会报错。注意p和src都是指向零地址的，但是实际内存中的低地址空间并不会真的分配给这些指针用于存放数据，只是cpu在按照nullptr查询这片低地址空间的映射并取数据或写数据时会发现查询没有结果从而报出异常。</span></span><br></pre></td></tr></table></figure></li><li><p>用户空间从0x08048000开始的第一块有效区域是**.text和.rodata段**。.text段也叫代码段，用于存放实际代码内容编译后对应的汇编指令。.rodata段即只读数据段，用于存放字符串字面量，其中的数据都是只能读取不能修改的。</p><p>e.g.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c风格操作，使用字符类型指针直接指向一个字符串字面量</span></span><br><span class="line"><span class="type">char</span> *p = <span class="string">&quot;abcd&quot;</span>; <span class="comment">//&quot;abcd&quot;这个字符串字面量存储在.rodata段。</span></span><br><span class="line">*p = <span class="string">&quot;a&quot;</span>; <span class="comment">//修改指针指向的内存空间里的数据，就是直接修改.rodata段里的&quot;abcd&quot;，这样做是不允许的，会在运行阶段报错。</span></span><br><span class="line"><span class="comment">//PS：目前许多高级语言已经规定普通指针不能直接指向字符串字面量，只有声明为const类型的指针才可以。这样就在编译阶段避免了修改.rodata段的数据这种错误操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C++风格操作，创建string类对象并将其赋值为一个字符串字面量</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s = <span class="string">&quot;abcd&quot;</span>; </span><br><span class="line"><span class="comment">//这一行代码做了三件事情，一个是在内存的栈stack上（下面有解释）创建string类对象s（这个对象内部通常包含了一些控制信息，比如一个指向字符数据的指针、字符串的当前长度和已分配内存的容量等），因为s是一个局部变量（PS：这行代码编译时会转化为汇编指令，储存在.text段）。</span></span><br><span class="line"><span class="comment">//第二个是在.rodata段创建&quot;abcd&quot;这个字符串字面量。</span></span><br><span class="line"><span class="comment">//最后一件事情是将&quot;abcd&quot;赋值给s，这步操作由string类的赋值构造函数完成，它首先会在内存的堆heap上动态分类一块大小足以容下&quot;abcd&quot;的内存，然后将.rodata段中的&quot;abcd&quot;拷贝到堆上分配的新内存里，再将对象s的内部指针指向这块堆上的新内存。</span></span><br><span class="line">s = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="comment">//跟c风格直接更改指针指向的.rodata段数据不同，这里的操作首先在.rodata段重新创建一块内存存放字符串&quot;a&quot;，然后触发string类的赋值操作(operator=)，释放对象s原本分配在堆上存放&quot;abcd&quot;的动态内存（并不会对.rodata段里的&quot;abcd&quot;产生实际影响），然后重新在堆上分配一块内存，将.rodata段新创建的&quot;a&quot;拷贝过来，并将s内部指针指向这块内存，同时更新s长度状态。</span></span><br></pre></td></tr></table></figure></li><li><p>再往上走，就是<strong>静态区（低到高依次为.data段和.bss段）</strong>：静态区用于存放可读可写的全局/静态变量，只要程序编译好，就会在.data段存放，一直到程序结束内存清空。.data和.bss的区别在于.data存放已经初始化且不为0的数据，而.bss段存放初始化为0或者未初始化的数据（程序编译时操作系统将其自动置为0）</p><blockquote><p>PS：<strong>为什么需要 <code>.bss</code> 段？</strong>这是一种<strong>优化</strong>。对于一个很大的、未初始化的全局数组<code>int big_array[10000];</code>，如果把它存放在 <code>.data</code>段，那么在可执行文件（如 ELF 文件）中就需要实实在在地占用<code>10000 * 4</code> 字节的空间来存储这些零。而如果放在<code>.bss</code> 段，可执行文件中<strong>只需要记录“需要分配 40000字节，并全部置为零”这个信息</strong>，而不需要存储那些零本身。这大大减小了可执行文件的大小。</p></blockquote></li><li><p><strong>堆（heap）</strong>，用于存放动态分配的内存。</p></li><li><p><strong>加载共享库</strong>，用于存放一些动态链接库的映射（windows下为*.dll库，linux下为*so库）。</p></li><li><p><strong>栈（stack）</strong>，一个程序进程运行时可能会产生多个不同的线程（如一道程序由多个函数构成，每个函数就是一个小线程），那么每个函数在内存上占有的私有空间就是栈。也就是说，函数内部的非静态局部变量都在栈上存储。</p><blockquote><h4 id="局部变量与栈-stack">局部变量与栈 (Stack)</h4><ul><li><strong>生命周期</strong>：局部变量的生命周期与它所在的函数或代码块绑定。<strong>函数开始执行时，它被创建；函数执行结束时，它必须被销毁。</strong></li><li><strong>栈的特性</strong>：栈是一种<strong>后进先出 (LIFO)</strong>的数据结构，这与函数的调用/返回机制完美契合。<ul><li><strong>函数调用</strong>：当一个函数被调用时，系统会在栈顶“压入”一个新的<strong>栈帧(StackFrame)</strong>。这个栈帧里包含了函数的参数、返回地址以及<strong>所有局部变量</strong>。</li><li><strong>函数返回</strong>：当函数执行完毕返回时，它的整个栈帧会被“弹出”，相当于瞬间释放了所有局部变量占用的空间。</li><li>对于虚拟内存的栈，地址是从高到低分配的。我们设栈顶指针esp，栈底指针ebp。当数据被压栈的时候，栈顶指针esp会向下移动一个数据大小的位置，而栈底指针不动，每次压栈都是在栈顶处（低地址）分配空间，并让栈顶指针下移。</li></ul></li><li><strong>为什么用栈？</strong><ul><li><strong>高效</strong>：栈的分配和释放只是移动一下栈顶指针(<code>esp</code>)，这是一个极快的操作，远比在堆上动态分配内存要快。</li><li><strong>自动管理</strong>：程序员无需关心局部变量的内存释放，它随着函数返回自动完成，避免了内存泄漏。</li></ul></li></ul></blockquote></li><li><p><strong>命令行参数和环境变量</strong>（环境变量即程序调用外部库的指定路径）</p></li><li><p>内存最高的1G大小的空间就是<strong>内核空间</strong>了，主要分为ZONE_DMA、ZONE_NORMAL、ZONE_HIGHMEM三块区域，其中ZONE_NORMAL用于存放进程的PCB（进程控制块，存储进程相关信息）以及内部线程私有的栈空间信息等，而ZONE_MEM为高端内存，用于映射高地址物理内存（此处不详细展开）。</p><p>需要注意的是，内存上的内核空间是进程间共享的（进程间通过匿名管道通信），用户空间才是各个进程私有的，相互无法访问。</p></li></ol><img src="https://caimotu.top/Picgo/image-20250814174159721.png" alt="image-20250814174159721" style="zoom: 67%;" /><p>以上就是一个进程的虚拟内存空间划分情况，接下来我们以一个简单的代码例子具体说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> gdata1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> gdata2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> gdata3;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> gdata4 = <span class="number">11</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> gdata5 = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> gdata6;</span><br><span class="line"><span class="comment">//以上六个变量都是全局变量，编译后会在可执行文件里的符号表里产符号映射，将变量名映射到运行时分配的内存地址。这些变量就称为数据，存放在虚拟内存的数据段里，具体的：gdata1和gdata4初始化不为零，存放在.data段；其余的初始化为零或未初始化，放在.bss段</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">12</span>;</span><br><span class="line">    <span class="comment">//在函数里声明的局部变量则不会在符号表里产生符号，这行代码编译后对应的是一个汇编指令:mov dword ptr[a],0Ch</span></span><br><span class="line">    <span class="comment">//表示将12这个值放到a这个变量在栈上的内存中（运行时指令本身放在.text段，12这个值被存放在栈上开辟好的4字节内存里）</span></span><br><span class="line">    <span class="comment">//PS:a这个字母并不会被CPU理解，实际的汇编指令里a应该是直接指向内存地址的一个指针，如ebp-4（ebp栈底是高地址），a只是编译器产生的方便程序员阅读的形式。因此只要程序运行到函数结束，栈上分配的线程对应的内存自动弹出销毁，进程就识别不到int a = 12这个信息了。</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="comment">//b,c与a同理，但是注意变量c没有初始化，所以是栈上的无效值，打印时会出现乱码。</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> e = <span class="number">13</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> g;</span><br><span class="line">    <span class="comment">//以上局部静态变量生命周期为整个程序运行过程，因次存放在静态数据段.data和.bss，但注意作用域还是局限于main函数</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; c &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; g &lt;&lt; endl;<span class="comment">//打印结果是乱码+0，因为g会被加载器自动置零</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指令角度详解函数调用堆栈过程">指令角度详解函数调用堆栈过程</h2><p>观察以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PS：本C++进阶讲解基于x86 32位linux环境&lt;/p&gt;
&lt;h2
id=&quot;进程的虚拟地址空间内存划分和布局&quot;&gt;进程的虚拟地址空间内存划分和布局&lt;/h2&gt;
&lt;p&gt;我们知道，任何的编程语言，在编译文件后都会产生的两种东西是指令和数据，并以可执行文件.exe的形式存储</summary>
      
    
    
    
    
    <category term="C++" scheme="https://ccloire.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法---线性表</title>
    <link href="https://ccloire.com/2025/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://ccloire.com/2025/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E8%A1%A8/</id>
    <published>2025-07-24T15:38:42.000Z</published>
    <updated>2025-08-07T13:58:02.016Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
    <category term="数据结构与算法" scheme="https://ccloire.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法---算法分析绪论</title>
    <link href="https://ccloire.com/2025/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E7%BB%AA%E8%AE%BA/"/>
    <id>https://ccloire.com/2025/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E7%BB%AA%E8%AE%BA/</id>
    <published>2025-07-23T07:57:19.000Z</published>
    <updated>2025-07-24T15:40:15.413Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://caimotu.top/Picgo/image-20250723160942140.png"alt="image-20250723160942140" /></p><p><img src="https://caimotu.top/Picgo/image-20250723161127459.png"alt="image-20250723161127459" /></p><img src="https://caimotu.top/Picgo/image-20250723161319758.png" alt="image-20250723161319758" style="zoom: 67%;" /><h1 id="三算法概述">三、算法概述</h1><h2 id="算法的五个特性">算法的五个特性：</h2><p>确定性、可行性、输入、输出、<strong>有穷性</strong>（一个算法一定是能终止的计算过程）</p><h2 id="评价算法的标准">评价算法的标准：</h2><img src="C:\Users\15458\Desktop\myblog\hexo\blog\source\_posts\数据结构与算法-算法分析绪论.assets\image-20250724220824467.png" alt="image-20250724220824467" style="zoom:50%;" /><h2 id="算法分析">算法分析：</h2><h3 id="时间复杂度">时间复杂度：</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://caimotu.top/Picgo/image-20250723160942140.png&quot;
alt=&quot;image-20250723160942140&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://caimotu.top/</summary>
      
    
    
    
    
    <category term="数据结构与算法" scheme="https://ccloire.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>南京4天3夜攻略</title>
    <link href="https://ccloire.com/2025/06/12/%E5%B7%A5%E5%85%B7%E6%9D%82%E6%96%87/%E5%8D%97%E4%BA%AC4%E5%A4%A93%E5%A4%9C%E6%94%BB%E7%95%A5/"/>
    <id>https://ccloire.com/2025/06/12/%E5%B7%A5%E5%85%B7%E6%9D%82%E6%96%87/%E5%8D%97%E4%BA%AC4%E5%A4%A93%E5%A4%9C%E6%94%BB%E7%95%A5/</id>
    <published>2025-06-12T04:47:58.000Z</published>
    <updated>2025-06-12T13:30:52.283Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://caimotu.top/Picgo/image-20250612162816123.png"alt="image-20250612162816123" /></p><h1 id="73">7.3</h1><h2 id="下午13301800">下午（13：30~18：00）：</h2><ul><li><p>（公寓打车17分钟）鸡鸣寺（提前一天预约，从山门进）（1.5h）</p></li><li><p>→步行15分钟到明城墙（0.5h）</p></li><li><p>→步行十分钟进玄武湖公园（2.5h）</p></li><li><p>→先锋书店分店＆寻魏金陵十二菜、鸭血粉丝汤（晚饭备选）</p></li></ul><img src="https://caimotu.top/Picgo/wps1.png" alt="img" style="zoom: 33%;" /><img src="https://caimotu.top/Picgo/wps2.png" alt="img" style="zoom:33%;" /><h2 id="晚上18302300">晚上：（18：30~23：00）</h2><ul><li><p>岗子村地铁站到夫子庙地铁站</p></li><li><p>→再步行十分钟到秦淮河夫子庙（小吃＋夜景），夫子庙内部门票30r</p></li><li><p>文德桥蓝调时刻：18：00~18：30左右</p></li><li><p>游船路线：携程搜“秦淮河画舫”，夜游游船票价120r，码头--&gt;白鹭洲--&gt;七彩水街—&gt;东水关—&gt;中华门—&gt;返程</p></li><li><p>避雷：夫子庙里的吃的；附近可去：小厨娘昆音雅宴、韩复兴老字号</p></li><li><p>老东门：金陵美术馆、陆式梅花糕、蒋友记、朱记小郑……</p></li></ul><p><img src="https://caimotu.top/Picgo/image-20250612171319927.png"alt="image-20250612171319927" /></p><h1 id="74">7.4</h1><h2 id="钟山风景区6301500-南博15001700">钟山风景区（6：30~15：00）+南博（15：00~17：00）</h2><ul><li>钟山风景区（中山陵提前七天预约，免费；明孝陵，灵谷寺，美龄宫，音乐台都提前1天预约，套票100r，美团直接搜）</li><li>景区观光车10r/人次，或者租电动/景区黑车（备选）</li></ul><p><img src="https://caimotu.top/Picgo/image-20250612191224381.png"alt="image-20250612191224381" /></p><ul><li><p>南博提前7天预约，攻略参考：<ahref="http://xhslink.com/a/xIvJtxrbsCMeb">http://xhslink.com/a/xIvJtxrbsCMeb</a></p><p>两小时速通路线：</p><img src="https://caimotu.top/Picgo/fe5861d2d7cf63c04d1dbf5e56c65c0.jpg" alt="fe5861d2d7cf63c04d1dbf5e56c65c0" style="zoom: 50%;" /></li></ul><h2 id="晚上新街口">晚上新街口</h2><ul><li>4号口孙中山铜像，7号口德基广场（7个厕所，8楼美术馆）</li><li>15号口对面石鼓路美食街</li><li>寻裕记现炒浇头、小潘记鸭血粉丝、澳挞……</li></ul><h1 id="75">7.5</h1><h2 id="上午">上午</h2><ul><li><p>总统府（提前三天预约，35r，用学生证可半价，8：30开，可考虑租讲解）</p></li><li><p>南博（前一天赶不及可以等7.5去）</p><img src="https://caimotu.top/Picgo/3dba4c3a094ff2700005bb3b714bda5.jpg" alt="3dba4c3a094ff2700005bb3b714bda5" style="zoom: 50%;" /></li></ul><h2 id="下午">下午</h2><ul><li><p>牛首山（门票学生证80r），打车到东门即可。</p></li><li><p>🏞️参观路线</p><ul><li>1️⃣走到山顶的观光车站后，乘坐扶手梯，再步行一小段便可以看到📍“佛顶圣境”四个大字，旁边的入口处就是网红打卡机位啦！</li><li>2️⃣再坐扶手梯往上+走过一小段楼梯，就可以看到📍“水池和大榴莲”了！水池和大榴莲的长廊都是很出片的地方！</li><li>3️⃣“大榴莲”的第一层可以看📍“卧佛”</li><li>4️⃣看完“卧佛”后，从大榴莲左边按照指示牌方向去参观📍“地宫”，进入地宫前门口就有免费的鞋套更换的噢</li><li>5️⃣先坐扶手梯下到“佛五层”也就是最深的一层，参观“千佛殿”，接着可以坐电梯上到“佛四层”的小阳台，拍网红推门视频</li><li>6️⃣看完之后坐电梯回到一层就好啦，中途会有一些文创店，也有很多佛像和雕刻可以观看</li><li>7️⃣出来后有时间可以去佛顶塔参观</li></ul><p><img src="https://caimotu.top/Picgo/image-20250612203244755.png"alt="image-20250612203244755" /></p></li></ul><h2 id="晚上">晚上</h2><p>金陵小镇，夜宵君陵紫金。</p><p>开放时间：到晚上九点半，学生票25，线上购票即可。</p><ul><li><p>游玩路线 桃蹊→文心馆→邻曲巷→满庭芳（客栈）→临霄台→绿筱园</p></li><li><p>演出信息</p><ul><li><p>1️⃣解音台</p><ul><li><p>金陵微笑（舞蹈表演，下午2点和4点两场，5min）</p></li><li><p>云织箴言（舞蹈表演，晚上7点和8点两场，5min）</p></li></ul></li><li><p>2️⃣文心馆</p><ul><li>流转时空（裸眼3D展示，循环播放）</li><li>天下文枢（文心馆广场，迎宾仪式，上午10点半和下午3点、6点三场，5min）</li><li>千里仁风（艺术装置，上午10：35和下午15：05、18：05三场，5min）</li><li>古风漫步（古装巡游，文心馆广场至解音台，下午3点一场，10min）</li></ul></li><li><p>3️⃣邻曲巷</p><ul><li>欢喜市集（氛围互动，下午4点一场，1h）</li></ul></li><li><p>4️⃣临霄台</p><ul><li>瑞雪金陵（场景造雪，上午11点半一场，10min）</li><li>梦雪樱飞（舞蹈表演，下午1点和5点两场，10min）</li><li>琴笛引梅（灯光秀，晚上7：10和8：10两场，4min）</li></ul></li><li><p>5️⃣绿筱园</p><ul><li>长相知（灯光秀，晚上7：20和8：20两场，5min）</li></ul></li></ul></li><li><p>园内娱乐</p><ul><li>✅汉服妆造</li><li>✅漆扇制作（文心馆）</li><li>✅围炉煮茶</li><li>✅盖章<ul><li>1️⃣文心馆出口×5枚 （服务台1枚，漆扇制作处4枚）</li><li>2️⃣前于记×1枚（墨不太足）</li></ul></li></ul></li></ul><h1 id="76">7.6</h1><h2 id="上午-1">上午</h2><ul><li><p>先导航到先锋书店（颐和路店）从这一端的颐和路开始Citywalk不用走回头路！</p></li><li><p>🚶路线：颐和路—西桥—金银街—南秀村—陶谷新村—先锋书店（五台山店）</p></li><li><p>👣一路的风景都很好看，还有很多咖啡店、古着店、文创店、特色餐厅等等，拍照打卡，闲逛聊天都很适合～</p></li><li><p>🍛逛完后去吃了科巷的石锅轩，锅巴很香，温泉蛋嫩滑，拌饭好吃！</p></li><li><p>📍颐和路： 一条颐和路，半部民国史晴天阳光透过树叶缝隙，斑驳的光影洒在黄墙上，歪脖子树依然浪漫。很多人在网红歪脖子树前打卡，可以提前规划好时间</p></li><li><p>📍西桥： 抬头是时代，低头是市井沿着颐和路走经过颐和公馆就可以到网红机位打卡（宁海中学北门可打卡紫峰大厦拍照机位）</p></li><li><p>📍金银街： 南大旁边的小街，有一些小摊、店铺和涂鸦墙可以打卡“我们如此热爱南京”的涂鸦！</p></li><li><p>📍南秀村、陶谷新村：咖啡店、古着店、文创店和特色餐厅聚集区，走累了可以停下来休息休息，小店和居民区完美融合，既年轻又充满生活气息真的很羡慕南大的同学，学校周围有那么多有意思的小店和舒适的社区🥹</p></li><li><p>推荐👍</p><ul><li><p>朱氏梅花糕：陶谷新村巷口上过电视的梅花糕！尝了豆沙味道很好吃，外皮脆脆的，内馅香甜但有点烫</p></li><li><p>学人书店：在陶谷新村里面。很多旧书，唱片，各种国内外旧物件，中古装饰品，很有氛围，可以慢慢看，慢慢淘</p></li></ul></li><li><p>📍先锋书店（五台山店）：书店的风格、陈列都很有特色，拍照出片所以人比较多。可以静下心来阅读，看看明信片墙上别人的故事，也写下自己的故事，感受文字的温度</p><img src="https://caimotu.top/Picgo/8aafcf0006c51f3c641b66eb5492ee6.jpg" alt="8aafcf0006c51f3c641b66eb5492ee6" style="zoom:33%;" /></li></ul><h2 id="下午-1">下午</h2><p>南京大屠杀死难者纪念馆（提前7天预约）</p><p>PS：吃滴</p><img src="https://caimotu.top/Picgo/c0c964fca484bd8464f4dc44fea9c80.jpg" alt="c0c964fca484bd8464f4dc44fea9c80" style="zoom:33%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://caimotu.top/Picgo/image-20250612162816123.png&quot;
alt=&quot;image-20250612162816123&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;73&quot;&gt;7.3&lt;/h1&gt;
&lt;h2 id=&quot;下午1</summary>
      
    
    
    
    
    <category term="生活" scheme="https://ccloire.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>计网实验--基本网络指令</title>
    <link href="https://ccloire.com/2025/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C-%E5%9F%BA%E6%9C%AC%E7%BD%91%E7%BB%9C%E6%8C%87%E4%BB%A4/"/>
    <id>https://ccloire.com/2025/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C-%E5%9F%BA%E6%9C%AC%E7%BD%91%E7%BB%9C%E6%8C%87%E4%BB%A4/</id>
    <published>2025-04-30T06:51:22.000Z</published>
    <updated>2025-06-13T16:35:37.141Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>《Attention is all your need》论文笔记</title>
    <link href="https://ccloire.com/2025/04/25/%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0/%E3%80%8AAttention%20is%20all%20your%20need%E3%80%8B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://ccloire.com/2025/04/25/%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0/%E3%80%8AAttention%20is%20all%20your%20need%E3%80%8B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</id>
    <published>2025-04-25T05:10:05.000Z</published>
    <updated>2025-06-13T16:35:45.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="论文逐步分解读">论文逐步分解读</h1><p>论文网址：</p><p><ahref="https://paperswithcode.com/paper/attention-is-all-you-need">https://paperswithcode.com/paper/attention-is-all-you-need</a></p><p><ahref="https://arxiv.org/abs/1706.03762">https://arxiv.org/abs/1706.03762</a></p><h2 id="transformer模型论文摘要解读">Transformer模型论文摘要解读</h2><p>这篇论文是著名的"Attention Is All YouNeed"论文的摘要，介绍了Transformer模型，这是深度学习和自然语言处理领域的一个里程碑式创新。以下是主要内容解读：</p><h3 id="研究背景与创新">研究背景与创新</h3><ul><li><p>之前的主流序列转导模型都基于复杂的循环神经网络(RNN)或卷积神经网络(CNN)，包含编码器和解码器结构</p></li><li><p>性能最好的模型还通过注意力机制连接编码器和解码器</p></li><li><p>论文提出了全新的网络架构"Transformer"，完全基于注意力机制，彻底摒弃了循环和卷积结构</p></li></ul><h3 id="实验结果">实验结果</h3><ul><li><p>在两个机器翻译任务上的实验表明，Transformer模型质量更优，同时更易于并行化，训练时间显著缩短</p></li><li><p>在WMT 2014英德翻译任务上达到28.4BLEU分，比当时最好的结果(包括集成模型)高出2个BLEU以上</p></li><li><p>在WMT 2014英法翻译任务上，单模型达到41.8BLEU的最新水平，仅用8个GPU训练3.5天，训练成本只是文献中最佳模型的一小部分</p></li></ul><h3 id="泛化能力">泛化能力</h3><ul><li>Transformer在其他任务上表现良好，成功应用于英语句法分析，无论是大规模还是有限的训练数据环境</li></ul><h2 id="研究背景">研究背景</h2><p>论文开篇指出：</p><ul><li><p>循环神经网络(RNN)特别是LSTM和GRU已成为序列建模和转导问题(如语言建模和机器翻译)的最先进方法</p></li><li><p>许多研究不断推动循环语言模型和编码器-解码器架构的边界</p></li></ul><h3 id="现有方法的局限性">现有方法的局限性</h3><p>RNN的关键局限：</p><ul><li><p>循环模型通常沿着输入和输出序列的符号位置进行计算</p></li><li><p>这种本质上的顺序性质阻碍了训练样例内的并行化，在更长序列长度下尤为关键</p></li><li><p>虽然一些工作通过分解技巧和条件计算提高了计算效率，但顺序计算的基本约束仍然存在</p></li></ul><h3 id="注意力机制的重要性">注意力机制的重要性</h3><ul><li><p>注意力机制已成为序列建模和转导模型的重要组成部分，允许在不考虑输入或输出序列中距离的情况下建模依赖关系</p></li><li><p>然而，大多数情况下，此类注意力机制与循环网络结合使用</p></li></ul><h3 id="transformer模型的提出">Transformer模型的提出</h3><ul><li><p>作者提出Transformer，一种完全放弃循环结构，而是完全依赖注意力机制来获取输入和输出间全局依赖关系的架构</p></li><li><p>Transformer允许更多并行化，在8个P100GPU上训练仅12小时就达到机器翻译的新水平</p></li></ul><h3 id="相关工作比较">相关工作比较</h3><p>论文讨论了其他减少顺序计算的模型：</p><ul><li><p>Extended NeuralGPU、ByteNet和ConvS2S都使用CNN作为基本构建块</p></li><li><p>这些模型中，关联两个任意输入或输出位置的操作数随距离增长(ConvS2S线性增长，ByteNet对数增长)</p></li><li><p>Transformer将此减少为常数级别的操作，尽管以注意力加权位置平均导致的有效分辨率降低为代价，但后续通过多头注意力机制进行了补偿（具体方法在3.2节）</p></li></ul><p>论文特别提到自注意力(self-attention)机制：</p><ul><li><p>用于关联单个序列中的不同位置以计算序列表示</p></li><li><p>已成功应用于阅读理解、摘要生成、文本蕴含和学习任务无关的句子表示</p></li></ul><h2 id="模型架构">模型架构</h2><h3id="二编码器encoder细节"><strong>二、编码器（Encoder）细节</strong></h3><h4 id="1-单层结构"><strong>1. 单层结构</strong></h4><p>每层编码器包含两个子层：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入 → 多头自注意力 → 残差连接+层归一化 → 前馈网络 → 残差连接+层归一化 → 输出</span><br></pre></td></tr></table></figure><h4 id="2-关键技术解析"><strong>2. 关键技术解析</strong></h4><ul><li><strong>多头自注意力 (Multi-Head Self-Attention)</strong><ul><li><strong>作用</strong>：让每个词查看全句其他词，动态计算关联权重例：句子"Animal didn't cross the street because it was tootired"中，"it"通过自注意力定位到"Animal"</li><li><strong>多头机制</strong>：将512维向量拆分为8个64维头，并行计算后拼接（类似8组不同滤镜观察句子）</li></ul></li><li><strong>前馈网络 (Position-wise FFN)</strong><ul><li><strong>结构</strong>：线性层→ReLU→线性层（公式：FFN(x)=max(0,xW1+b1)W2+b2）</li><li><strong>特性</strong>：对每个词独立处理，无位置交互（与自注意力互补）</li></ul></li><li><strong>残差连接 + 层归一化</strong><ul><li><strong>操作</strong>：输出 = LayerNorm(原始x + 计算后的x)</li><li><strong>目的</strong>：缓解梯度消失，加速深层网络训练</li><li><strong>维度保持</strong>：所有子层输出保持d_model=512，便于叠加</li></ul></li></ul><h4 id="3-6层堆叠的意义"><strong>3. 6层堆叠的意义</strong></h4><ul><li>底层：学习局部语法（如名词短语结构）</li><li>中层：捕捉句间逻辑关系（因果、转折）</li><li>高层：整合全局语义（篇章级信息）</li></ul><hr /><h3id="三解码器decoder细节"><strong>三、解码器（Decoder）细节</strong></h3><h4 id="1-单层结构-1"><strong>1. 单层结构</strong></h4><p>每层解码器包含三个子层：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入 → 掩码自注意力 → 残差连接+层归一化 → 编码器-解码器注意力 → 残差连接+层归一化 → 前馈网络 → 残接+层归一化 → 输出</span><br></pre></td></tr></table></figure><h4 id="2-核心差异点"><strong>2. 核心差异点</strong></h4><ul><li><strong>掩码自注意力 (Masked Self-Attention)</strong><ul><li><strong>实现方式</strong>：在softmax前将未来位置权重设为-∞</li><li><strong>作用</strong>：确保预测第t个词时仅依赖前t-1个词 例：生成"Ilove"时，第三个词只能基于前两个词预测</li></ul></li><li><strong>编码器-解码器注意力</strong><ul><li><strong>Query来源</strong>：解码器当前状态</li><li><strong>Key/Value来源</strong>：编码器最终输出</li><li><strong>功能</strong>：实现源语言与目标语言的词对齐可视化案例：翻译"knowledge"时可能重点关注"知识"</li></ul></li></ul><h4 id="3-位置偏移技巧"><strong>3. 位置偏移技巧</strong></h4><ul><li><strong>输出嵌入右移一位</strong>：训练时解码器输入是目标序列右移后的结果，确保当前位置预测仅依赖历史信息</li></ul><hr /><h3 id="q---a">Q---A</h3><h4 id="q1-为什么每层都要残差连接"><strong>Q1:为什么每层都要残差连接？</strong></h4><ul><li>深层网络信号传递容易衰减，残差结构保留原始信息（类似高速公路）</li><li>实验证明：无残差连接时6层网络难以收敛</li></ul><h4 id="q2-层归一化-vs-批归一化"><strong>Q2: 层归一化 vs批归一化</strong></h4><ul><li>批归一化：对同一批次内所有样本的同一特征做归一化（适合CV）</li><li><strong>层归一化</strong>：对单个样本的所有特征做归一化（更适合NLP变长序列）</li></ul><h4 id="q3-为什么用6层而不是更多"><strong>Q3:为什么用6层而不是更多？</strong></h4><ul><li>论文实验表明：6层在翻译任务上达到效率与效果的平衡（后续研究如BERT使用12/24层，需更多数据与算力支持）</li></ul><hr /><h3 id="五实例演算流程"><strong>五、实例演算流程</strong></h3><p>以英译中为例：</p><ol type="1"><li><strong>编码过程</strong> 输入："The cat sat on the mat"经过6层编码器后，每个词被转换为包含上下文信息的512维向量</li><li><strong>解码过程</strong> 生成："猫坐在垫子上"<ul><li>第1步：接收起始符，通过掩码自注意力初始化状态</li><li>第2步：生成"猫"时，编码器-解码器注意力聚焦"cat"</li><li>第3步：生成"坐"时，自注意力关联"sat"，编码器注意力保持对"cat"关注</li><li>后续步骤同理，直至生成终止符</li></ul></li></ol><hr /><p><strong>关键结论</strong>：Transformer通过<strong>堆叠自注意力层+位置感知前馈网络</strong>，实现了：① 完全并行化计算 ② 长距离依赖捕捉 ③端到端对齐能力。这种设计成为后续GPT、BERT等模型的基石。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;论文逐步分解读&quot;&gt;论文逐步分解读&lt;/h1&gt;
&lt;p&gt;论文网址：&lt;/p&gt;
&lt;p&gt;&lt;a
href=&quot;https://paperswithcode.com/paper/attention-is-all-you-need&quot;&gt;https://paperswithcode</summary>
      
    
    
    
    
    <category term="多模态大模型论文学习" scheme="https://ccloire.com/tags/%E5%A4%9A%E6%A8%A1%E6%80%81%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>RNN简介</title>
    <link href="https://ccloire.com/2025/04/25/%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0/RNN%E7%AE%80%E4%BB%8B/"/>
    <id>https://ccloire.com/2025/04/25/%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0/RNN%E7%AE%80%E4%BB%8B/</id>
    <published>2025-04-25T05:05:09.000Z</published>
    <updated>2025-06-13T16:35:28.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rnn循环神经网络简要介绍">RNN(循环神经网络)简要介绍</h1><h2 id="简介">简介</h2><p>循环神经网络模型以序列数据为输入（数据内部的元素是有顺序关系的），如文章、语句、一周的天气信息、三个月的股市指数等。与传统的前馈网络不同的是，RNN模型处理序列数据能够获取更多的语义信息，时序信息等。</p><p>处理任务示例：</p><p>以NER（命名实体识别）为例，从自然语言文本中识别真实世界中的实体名及其类别。如：</p><p>句子1：I like eating apple!——其中的apple指的是苹果食物</p><p>句子2：The Apple is a great company！——其中的Apple指的是苹果公司</p><p>而如果是传统的DNN（深度神经网络）模型，由于输入方式为逐元素输入，无法有效获取上下文信息，则若训练集中的apple一词大部分被标记为苹果食物，那么对测试集中的apple处理也将全部标记为苹果食物而非根据实际上下文推断。</p><h2 id="模型提出">模型提出</h2><h3 id="基本rnn结构">基本RNN结构</h3><p>为了解决普通DNN（深度神经网络）逐元素输入而无法有效获取上下文信息的问题。RNN最基本的改良点在于增加一个模块用于储存上下文信息，下图即是一个典型的RNN结构示意：</p><img src="https://caimotu.top/Picgo/image-20250417165208064.png" alt="image-20250417165208064" style="zoom:33%;" /><p>其中I（输入序列）到O（输出序列）的过程增加了一个保存上下文信息的权重矩阵W，也就是每次输出O不仅要考虑当前的输入数据I，还要考虑上一次输出的隐藏序列W（保存上下文）。RNN就是一个循环递归地处理上述输入输出的过程。</p><h3 id="rnn展开结构">RNN展开结构</h3><p>将上图的基本结构展开，就成为了下图展示的模型计算过程：</p><img src="https://caimotu.top/Picgo/ebe46967a3e80dab4c04635a2c6785f.jpg" alt="ebe46967a3e80dab4c04635a2c6785f" style="zoom:33%;" /><p>其中 <span class="math inline">\(x_i\)</span>表示i时刻的模型输入，<span class="math inline">\(y_i\)</span>表示<spanclass="math inline">\(x_i\)</span>对应的输出结果，模型计算公式如下：<span class="math display">\[\begin{split}y_i = g(Vh_i)\\\\h_i = f(Ux_i + Wh_{i-1})\end{split}\]</span>U表示当前输入数据的权重因子，W表示决定上下文信息影响程度的参数矩阵，<spanclass="math inline">\(h_i\)</span>则表示当前隐藏层的输出隐变量。可以看出决定当前输出<spanclass="math inline">\(y_i\)</span>的隐变量<spanclass="math inline">\(h_i\)</span>不仅由当前输入<spanclass="math inline">\(x_i\)</span>决定，也与上一时刻的隐变量<spanclass="math inline">\(h_{i-1}\)</span>有关。（PS：整个模型计算过程里用的参数矩阵W是一定的）</p><h2 id="rnn模型结构变化">RNN模型结构变化</h2><p>上述展开结构会根据输入长度和输出长度的变化而产生不同的结构</p><h3 id="n-to-n结构">N to N结构</h3><p>这类结构的输入长度与输出长度相同，也即每一个输入值都会对应一个输出值。通常用于逐序列判断或分类任务（如序列标注，NER，视频帧分类等）。示例图与计算模型如2.2所述。</p><h3 id="n-to-1结构">N to 1结构</h3><p>这类结构只有一个输出值，表示输出结果包含了整个输入序列的语义信息和上下文信息。结构示意图：</p><img src="https://caimotu.top/Picgo/8606007dd425e9195f0c11d4719656f.jpg" alt="8606007dd425e9195f0c11d4719656f" style="zoom: 50%;" /><p>计算模型： <span class="math display">\[\begin{split}Y = y_N = g(Vh_N)\\h_i = f(Ux_i+ Wh_{i-1})\end{split}\]</span> 这类结构通常用于文字分类、文章分类以及图像分类任务。</p><h3 id="1-to-n结构">1 to N结构</h3><p>一个输入数据对应一系列输出，其意义是一个起始状态或种子数据会随时间变化生成一个序列的输出结果。</p><p>若输入数据只在首个时刻输入，则计算示意图如下所示：</p><img src="https://caimotu.top/Picgo/112ce7e4cbc3de28915ec314a82fdba.jpg" alt="112ce7e4cbc3de28915ec314a82fdba" style="zoom:50%;" /><p>而若输入数据在每个时刻都作为输入，则示意图如下：</p><img src="https://caimotu.top/Picgo/bd9767d63cc2fd88b9b265d80777250.jpg" alt="bd9767d63cc2fd88b9b265d80777250" style="zoom:50%;" /><p>该结构通常用于由图像自动生成文章、类别生成音乐、文章、代码等由种子数据生成序列的任务。</p><h3 id="n-to-m结构encoder-decoder模型seq2seq模型">N toM结构（encoder-decoder模型、seq2seq模型）</h3><p>最后一类是输入输出序列长度不相等的结构。通常采用一个N to 1结构和一个1to M结构组合来实现，如下图：</p><img src="https://caimotu.top/Picgo/f529bf34ed1f0a34e98af6cd3b390b2.jpg" alt="f529bf34ed1f0a34e98af6cd3b390b2" style="zoom:50%;" /><img src="https://caimotu.top/Picgo/6355d703227ac85b3ac67a61c52bd84.jpg" alt="6355d703227ac85b3ac67a61c52bd84" style="zoom: 33%;" /><p>由上图可以看出，两个不同长度的RNN模型组合可以控制输出序列长度。两个模型之间通过一个上下文向量C来链接，其中C可作为第二个RNN模型的输入数据并对初始隐藏变量<spanclass="math inline">\(h_0^{&#39;}\)</span>​进行初始化（如第一个图），也可以直接被用来初始化第二个RNN模型的隐藏变量（如第二个图）。</p><p>常用的上下文向量C的求解方法有： <span class="math display">\[\begin{split}c = h_N\\c = g(h_N)\\c = g(h_1 :: h_N)\end{split}\]</span>第一种方法直接将encoder的输出作为上下文向量；第二种方法则需要先对encoder输出进行变换；第三种方法则将encoder的一个输出序列进行变换，而非单一选取最后一个输出。</p><p>通常将第一个RNN模型作为encoder（编码器），第二个RNN模型成为decoder（解码器）。通过这样NtoM的RNN模型，我们可以处理各类序列处理任务，如语音识别，文本摘要，机器翻译，图像描述生成等。</p><h2 id="梯度消失与梯度爆炸">梯度消失与梯度爆炸</h2><h3 id="概念">概念</h3><p>由于RNN中的上下文参数矩阵是权重共享的，即当进行梯度更新时，对该矩阵求偏导数时需要加入时序影响，将导致存在基于时序数量的权重“连乘”。若某一阶段权重值过小，结合“连乘”将导致最终权重趋于“无穷小”（即等于0），此现象称为“梯度消失”。相反地，若权重值过大，经连乘后将导致权重值变得过大，称为“梯度爆炸”。</p><p>与普通NN的梯度消失及梯度爆炸不同，RNN的梯度爆炸（或消失）是根本原因是“连乘”，是在反向传播的某一阶段出现的，在此之前的反向传播不受影响。</p><h3 id="如何解决">如何解决</h3><p><strong>1. 梯度爆炸的解决</strong></p><p>1）梯度裁剪</p><p>​梯度裁剪即为梯度更新时的梯度设置上限，当超过阈值将强制裁剪，避免出现过高阈值。</p><p><strong>2. 梯度消失的解决</strong></p><p>1）使用Relu激活函数</p><p>​使用Relu激活函数解决梯度消失的原理是，Relu函数在自变量大于0是，因变量恒为1，由此避免梯度过小。</p><p>2）变更RNN结构</p><p>​ 改用变种版本的RNN结构，常见的包括LSTM模型及GRU模型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;rnn循环神经网络简要介绍&quot;&gt;RNN(循环神经网络)简要介绍&lt;/h1&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;循环神经网络模型以序列数据为输入（数据内部的元素是有顺序关系的），如文章、语句、一周的天气信息、三个月的股市指数等。与传统的前馈网络不同的是，</summary>
      
    
    
    
    
    <category term="深度学习" scheme="https://ccloire.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络--第一章：计算机网络和因特网</title>
    <link href="https://ccloire.com/2025/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/"/>
    <id>https://ccloire.com/2025/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/</id>
    <published>2025-04-08T07:11:17.000Z</published>
    <updated>2025-06-13T16:20:27.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络和因特网">计算机网络和因特网</h1><p>章节导读：</p><ul><li>在这个章节，我们需要先了解什么是因特网（Internet），什么是协议（protocol）。</li><li>之后了解什么是网络边缘(network edge)：主机hosts，接入网accessnetwork以及物理媒介physical media。</li><li>边缘之后便是网络核心(networkcore)的概念：主要了解两种网络技术——分组交换packetswitching以及电路交换circuitswitching，这是互联网的技术基础，会涉及到包(packet）、路由器(router)和链路层交换机(link-layerswitch)这些概念；以及互联网的结构。</li><li>再往下是网络性能（performance）：了解数据从源端发送到目的地时数据包是如何丢失(loss)或者延迟(delay)的。这一部分内容会将吞吐量(throughput)作为一种性能指标，衡量字节信号从源转发到目的地的速率。</li><li>之后我们需要了解互联网中的协议层(protocol layers)和服务模型(servicesmodels)相关内容</li><li>最后便是关于互联网中的安全问题和发展历史介绍。</li></ul><p>PS：这一章只是计算机网络的整体概述，各部分的具体理论实现会在后面的章节详细展开。</p><h2 id="什么是因特网">什么是因特网</h2><h3 id="具体构成角度描述">具体构成角度描述</h3><img src="https://caimotu.top/Picgo/image-20250409212415280.png" alt="image-20250409212415280" style="zoom:50%;" /><p>因特网中一个与我们密切相关的组成部分就是主机(hosts)或端系统(endsystem)，像我们使用的电脑，手机就属于端系统。<strong>端系统</strong>又通过<strong>通信链路(communicationlink)</strong> 和 **分组交换机(packetswitch)**连接到一起，组成我们熟知的因特网。</p><p>通信链路属于网络边缘，实际上由不同类型的物理媒介组成，不同的链路有不同的传输速率（以bit/s或bps）度量。</p><p>分组交换机属于网络核心。发送端发送数据时会先将数据分段，每段加上首部字节，这样形成的信息就是<strong>分组</strong>。而分组交换机则负责从一条入通信链路接收到达的分组，向它的一条出通信链路发送该分组（接收和发送分组时如何选择路径在本文“3.网络核心”中的分组交换部分会详细展开）。分组交换机有两种主要类型：路由器和链路层交换机。</p><p>**因特网服务提供商(Internet ServiceProvider,ISP)**就是通过各种链路互联的分组交换机给端系统提供接入互联网的服务，像住宅区ISP，大学ISP等等。每个ISP本身就是一个由多台分组交换机和多段通信链路以及它的客户端系统组成的网络。</p><p>因特网中每个部件在实际运行的时候依赖的其实是一系列互联网<strong>协议(protocol)</strong>，这些协议控制信息的接收和发送。TCP(TransformerControl Protocol，传输控制协议)和IP(InternetProtocol，网际协议)就是因特网中两个最重要的协议。这些协议是由因特网工程任务组(InternetEngineering TaskForce，IETF)来制定研发的，他们的标准文档被称为请求评论(Request ForComment，RFC)。</p><p>因此计算机网络这门课实际上就是在研究这些网络协议的构成，原理和工作方式。</p><h3 id="服务角度描述">服务角度描述</h3><p>除了上面用具体构成角度来解读互联网以外，我们还可以从服务角度描述互联网，也就是为应用程序提供服务的基础设施(infrastructure)。我们在互联网获取和发送信息都是通过一些网络应用程序实现的，这些应用程序会涉及到多个相互链接的端系统，因此也被称为<strong>分布式应用程序(distributedapplication)</strong>。而互联网中的通信基础设施就为这些应用提供了可以用于向另一个端系统发送信息的编程接口，也叫<strong>套接字接口(socketinterface)</strong>，这个接口不仅规定了发送方应用应该遵循的规则，也提供了多种因特网服务，这些内容将在第二章应用层中详细展开。</p><h3 id="网络协议">网络协议</h3><p>协议定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及发送或接收一条报文或者进行其他事件时通信实体所采取的动作。</p><p>下面介绍一个简单的TCP协议例子：当我们在计算机中输入一个网页的URL时，我们的计算机会先向网页的web服务器发送一条连接请求报文，web服务器收到请求后会返回一条连接响应报文。计算机得知能正常请求web的文档后，便会发送一条GET报文，声明要从该web服务器请求访问的页面域名。最后，web服务器便向计算机发送该web网页文件。</p><img src="https://caimotu.top/Picgo/image-20250409214625582.png" alt="image-20250409214625582" style="zoom:50%;" /><h2 id="网络边缘">网络边缘</h2><p>网络边缘的组成部分有主机，接入网和物理媒介。</p><h3 id="主机">主机：</h3><p>运行分布式应用程序，主机之间的通信模式主要有两种：</p><ul><li>客户/服务器模式 Client-Server (C/S)<ul><li>客户端向服务器请求、接收服务</li><li>比如：蓝牙外设 Bluetooth Peripheral (Slave) -Master</li></ul></li><li>对等模式 Peer-to-Peer (P2P)<ul><li>无服务器端 No server-side</li><li>比如：Blockchain/BitTorrent/迅雷/网盘</li></ul></li></ul><h3 id="接入网access-network">接入网(access network)：</h3><p>接入网指的是端系统在物理上连接到边缘路由器(edgeroute)的网络；边缘路由器是端系统连接到远程端系统的路径上的第一台分组交换机。接入网根据使用环境可以分为三种类型：</p><ul><li>住宅接入 residential accessnetwork(数字用户线，电缆，FTTH，拨号和卫星)</li><li>单位接入 institutional access networks(school,company中常见，以太网和WiFi)</li><li>移动接入 mobile access networks (4G/5G和LTE)</li></ul><p>研究这三种接入网，我们需要重点了解的是它们的传输速率(bits persecond,bps)以及它们的用户在多大程度上和其他用户共享该接入网。</p><p>下面就这三种接入网详细展开描述：</p><h4 id="住宅接入">住宅接入</h4><p>当今的住宅接入有两种比较主流的方式：数字用户线（Digital SubscribeLine，交换数字数据和语音信息）和电缆（cable，交换数字数据和广播视频信息）。</p><ul><li><p>数字用户线（DSL）：</p><img src="https://caimotu.top/Picgo/image-20250411114800845.png" alt="image-20250411114800845" style="zoom:50%;" /><p>住宅通过本地电话公司（也即用户的ISP）提供的本地电话接入来获取因特网接入服务。本地电话接入就是用户主机通过现有的电话线（双绞铜线，后面物理媒介部分会详细介绍）来和本地中心局(centeroffice，CO)中的数字用户线接入复用器(DSLAM)交换数据，交换数据这一动作就意味着主机成功接入互联网。</p><p>我们知道家庭电话线只能以模拟信号的形式（也即高频音）传输信息，所以为了同时承载两种信号——数据信号（如因特网接入）和语音信号（如电话呼叫），让它们共享DSL链路，需要采用频分复用技术（frequencydivision multiplexing，FDM，后面的分组交换部分内容会详细介绍），对不同的信号使用不同频率进行编码：</p><p>高速下行信道：50kHz~1MHz频段（端系统接收来自基站的数据信号）</p><p>中速上行信道：4kHz~50kHz频段（端系统向基站发送数据信号）</p><p>普通双向电话信道：0~4kHz频段（端系统和基站双向交换电话信号）</p><p>而且为了将数字数据信号以模拟信号的形式进入电话线，DSL接入网还使用了一种叫DSL调制解调器的部件，负责家庭端的信号转换；而信号通过电话线传输给CO端后，会经过数字用户线接入复用器（DSLAM）将上行信道中的模拟信号转化回数字数据信号。</p><p>那么不同的信号在端系统和基站又是怎么划分到不同信道并被分别解调的呢？这就又涉及到一种叫<strong>分配器</strong>的部件。</p><ul><li>当信号从用户端系统发送到基站时：语音信号会经分配器的分隔进入普通双向电话信道；而数据信号则会先由家庭的DSL调制解调器划分进入上行信道（DSL调制解调器在这里不仅起到将数据信号转化为模拟形式的作用，还有将信道分为上行与下行信道的作用），再进入分配器和语音信号一起通过电话线DSL传输。在到达基站也就是CO一侧后，上行信道中的模拟信号又会经DSLAM转化回数字数据信号，并在DSLAM作用下和普通双向电话信道中的语音信号分隔开，分别送往互联网和电话网。</li><li>当信号从基站发送到用户端系统时：传输过程与上述反向同理，但数据信号要经下行信道传输。</li></ul><p>（PS：成百上千个家庭的数字用户线接入的是同一个DSLAM，但DSL接入网在传输时容量和带宽是不共享的，每个家庭都拥有独享的数字用户线）</p><p>在不同的信道，由于编码频率不同，信号传输的速率也会有所不同。DSL标准定义了多个传输速率(随技术变革会越来越高)，下行传输速率一般为24—52Mbps，上行传播速率一般为3.5—16Mbps（下行比上行快，因此这种接入也被称为不对称接入）。而在实际的传输服务中，传输速率可能会比上述标准低，这是因为本地电话公司会提供分等级的服务，低级服务的传输速率可能会比较低；以及实际的住宅和中心局距离，双绞线的规范等因素都会影响传输速率。（PS：DSL接入网一般只能在住宅与中心局距离5~10英里内的情况下使用）</p></li><li><p>电缆因特网接入：</p><img src="https://caimotu.top/Picgo/image-20250411115649973.png" alt="image-20250411115649973" style="zoom: 33%;" /><p>住宅利用有线电视公司提供的有线电视基础设施（光纤和同轴电缆）来获取因特网接入服务。由于整个系统使用的是光纤和同轴电缆，因此也被称为混合光纤同轴系统（HybridFiber Coax，HFC）。</p><ul><li><p>与DSL接入使用DSL调制解调器不同，电缆因特网接入需要使用电缆调制解调器（cablemodem），将数字信号转为模拟信号并将HFC网络划分为上行和下行信道（没有像DSL接入网那样的电话双向信道）；而在电缆头端，则使用电缆调制解调器终端系统（CMTS）来把下行信道中的模拟信号转回数字信号（功能相当于DSLAM）。</p><p>另一个不同之处是电缆因特网接入的用户共享广播媒体，也就是共享上行和下行信道，因此多个用户同时经下行信道下载电缆头端发送的视频文件时，传输速率会大大降低甚至发生碰撞问题（第6章会更加详细描述）。</p></li><li><p>与DSL接入相同的是，电缆因特网接入也属于不对称接入，即下行信道的传播速率要比上行信道的高。电缆因特网接入可提供40Mbps—1.2Gbps的下行传输速率和30—100Mbps的上行传输速率。</p></li></ul></li><li><p>DSL和电缆是以往大多数家庭使用的接入网形式，但一种更高速率的新兴技术——光纤到户（FiberTo The Home，FTTH）逐渐在各个国家的家庭里普及。</p><img src="https://caimotu.top/Picgo/image-20250411150817230.png" alt="image-20250411150817230" style="zoom:33%;" /><p>这种技术是从本地中心局直接提供一条到家庭的光线路径，最简单的光纤分布网络就是直接网络（中心局发出一根多个家庭共享的光纤，在接近住户处再由分配器分成每户一根光纤），它分为两种体系结构：有源光纤网络（ActiveOptical Network，AON，第六章详细讨论）和无源光纤网络（Passive OpticalNetwork，PON）。</p><p>如图是PON体系的示意图，这里我们可以简单解释以下其传输过程：每个家庭都配有一个光纤网络接收器（ONT），并由专门的光纤接到光纤分配器上，多个家庭通过分配器集结到一根共享的光纤上，该光纤再和中心局中的光纤线路端接器（OLT）相连。</p></li><li><p>在以上三种接入网形式无法提供时（如偏远乡村环境），家庭有时也会使用卫星链路或者拨号接入（类似DSL，但速率极低）。</p></li></ul><h4 id="单位接入">单位接入</h4><img src="https://caimotu.top/Picgo/image-20250411201727538.png" alt="image-20250411201727538" style="zoom:50%;" /><p>在公司，大学或者如今越来越多的家庭里，通常会使用**局域网（LAN）**来将端系统接入边缘路由器。</p><p>有线局域网接入最流行的技术就是<strong>以太网</strong>；而无线局域网接入最流行的技术则是我们当今无处不在的<strong>WiFi</strong>。以太网接入中，用户和web服务器使用双绞铜线与一台以太网交换机相连（第六章将详细介绍），这些以太网交换机或者他们相连形成的网络再去连接到更大的因特网核心。WiFi接入中，用户会向一个无线基站接入点发送或接收分组，这个接入点再和企业网相连接（通常就是通过以太网交换机接入有线因特网，因此也是无线局域网和有线局域网的结合）。</p><p>以太网的传输速率通常有1Gbps，10Gbps，最高可达100Gbps；而WiFi传输速率则比较慢，如今的WiFi5可提供3.5Gbps速率，WiFi 6可提供9.6Gbps的速率，WiFi7可提供高达30Gbps的速率。</p><h4 id="移动接入">移动接入</h4><p>在局域网接入中，往往端系统都需要在接入点或以太网交换机的附近一定范围内；而如今4G/5G的通信方式允许我们在大范围内移动的同时也保持接入因特网，在这种接入网中，端系统通过蜂窝网提供商运营的基站来发送和接收分组的，允许用户在基站的数万米内依然保持连接。</p><p>下图是一个经典的家庭网络示意图，包含了一个家庭可能使用的每一种接入网方式。PS：电缆接入网/DSL接入网中的调制解调器和有线局域网/无线局域网的以太网交换机以及互联了移动通信基站的路由器往往是装在一个盒子里的，统称为家庭路由器。</p><img src="https://caimotu.top/Picgo/image-20250411142347759.png" style="zoom: 33%;" /><h3 id="物理媒介physical-media">物理媒介(physical media)：</h3><p>物理媒介分为两种类型：导引型媒体和非导引型媒体。</p><h4 id="双绞铜线">双绞铜线</h4><p>最便宜且最常用的导引型传输媒体就是双绞铜线。DSL技术和局域网接入都会使用到双绞铜线这种材料。</p><img src="https://caimotu.top/Picgo/image-20250412122442735.png" alt="image-20250412122442735" style="zoom:33%;" /><h4 id="同轴电缆">同轴电缆</h4><p>同轴电缆和双绞铜线类似都由两个铜导体组成，不同的是同轴电缆中这两个导体同心而非并行。由于这种结构以及它特殊的绝缘层和保护层，同轴电缆能达到较高的数据传输速率，常被用作共享媒体，充当前面所述的电缆因特网接入/电视系统的物理媒介。</p><img src="https://caimotu.top/Picgo/image-20250412124318439.png" alt="image-20250412124318439" style="zoom:33%;" /><h4 id="光纤">光纤</h4><ul><li><p>导引光脉冲，每个脉冲表示一个bit，在玻璃纤维中传输</p></li><li><p>高速:</p><ul><li>如10 Gbps-100Gbps传输速率</li></ul></li><li><p>低误码率:</p></li><li><p>中继器相隔很远</p></li><li><p>不受电磁噪声影响</p></li><li><p>光信号衰减极低</p></li><li><p>光设备成本高，因此光纤多用于长途运输而非短途传输（如家庭接入网或者LAN局域网就很少用光纤）</p></li></ul><h4 id="无线电">无线电</h4><img src="https://caimotu.top/Picgo/image-20250412125530083.png" alt="image-20250412125530083" style="zoom:33%;" /><h2 id="网络核心">网络核心</h2><p>讨论完网络边缘，我们便开始讨论网络核心部分——链接因特网端系统的分组交换机和通信链路构成的网状网络。</p><p>在本文一开始我们介绍过分组的概念，也就是端系统发送出来的数据分段后加上首部字节后形成的数据段。那么这些数据段是如何在端系统之间交换的呢。方式有两种——分组交换和电路交换。下面我们分别简要讨论这两种</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络和因特网&quot;&gt;计算机网络和因特网&lt;/h1&gt;
&lt;p&gt;章节导读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在这个章节，我们需要先了解什么是因特网（Internet），什么是协议（protocol）。&lt;/li&gt;
&lt;li&gt;之后了解什么是网络边缘(network edge</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="https://ccloire.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Go语言初阶</title>
    <link href="https://ccloire.com/2025/03/31/Go%E8%AF%AD%E8%A8%80%E5%88%9D%E9%98%B6/"/>
    <id>https://ccloire.com/2025/03/31/Go%E8%AF%AD%E8%A8%80%E5%88%9D%E9%98%B6/</id>
    <published>2025-03-31T08:41:25.000Z</published>
    <updated>2025-03-31T15:04:28.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go第一印象">Go第一印象</h1><p>Go语言特点：简单，便于管理编写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个struct类</span></span><br><span class="line"><span class="keyword">type</span> Class <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    PublicVariable <span class="type">string</span> <span class="comment">//公共变量的声明--变量类型首字母大写即可</span></span><br><span class="line">    privateVariable <span class="type">string</span> <span class="comment">//私有变量的声明--变量类型首字母小写即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共方法（函数）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SomeClass)</span></span> PublicMethod() (result )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;go第一印象&quot;&gt;Go第一印象&lt;/h1&gt;
&lt;p&gt;Go语言特点：简单，便于管理编写&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>markdown语法总结</title>
    <link href="https://ccloire.com/2025/02/27/%E5%B7%A5%E5%85%B7%E6%9D%82%E6%96%87/markdown%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://ccloire.com/2025/02/27/%E5%B7%A5%E5%85%B7%E6%9D%82%E6%96%87/markdown%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2025-02-27T13:10:29.000Z</published>
    <updated>2025-06-13T16:27:23.791Z</updated>
    
    <content type="html"><![CDATA[<h1id="markdown语法总结"><span style="font-size:0.8em;">Markdown语法总结</span></h1><p>前置声明：以下大部分语法在Typora中都可以通过右键找到对应的快捷插件，学习语法一方面是方便我们灵活编辑md文本，无须反复腾出手去滑动点击鼠标，一方面是为了在一般的编辑器里也能正确编写md文件。</p><h2 id="标题">标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题  </span></span><br><span class="line"><span class="section">## 二级标题  </span></span><br><span class="line"><span class="section">### 三级标题  </span></span><br><span class="line"><span class="section">#### 四级标题  </span></span><br><span class="line"><span class="section">##### 五级标题  </span></span><br><span class="line"><span class="section">###### 六级标题  </span></span><br><span class="line"></span><br><span class="line">PS：在#后面要添加一个空格再跟标题内容</span><br></pre></td></tr></table></figure><h2 id="段落与换行">段落与换行</h2><ol type="1"><li>普通换行需要在换行处添加两个空格，如：</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里是第一行（随后跟两个空格 + “enter”，再打出下一行内容即可）  </span><br><span class="line">这里是第二行</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>换段落（行与行之间多一空白行）：</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里是第一段（随后连续打出两个回车enter）</span><br><span class="line"></span><br><span class="line">这里是第二段</span><br></pre></td></tr></table></figure><p>PS：上述规则应该适用于一般的文本编辑器里编写markdown文件的情况。</p><p>但是不同编辑器/网页由于使用的渲染器不同，实际展现出来的效果也可能有所差异。比如本人在使用Typora1.8.10版本时发现一个enter就会被实时渲染成换段落，即使使用两个空格再enter也会直接被渲染为换段落。</p><p>因此建议确实需要换行功能的博主，<strong>进入源代码模式</strong>编写markdown文档，便于使用原始版本的语法而不会被Typora渲染器的不同效果影响。如果觉得换行和换段落区别不大，也可以直接按照Typora的特性来——统一使用一个enter换段落的方式开启新的一段内容。</p><h2 id="文本效果加粗与斜体与中划线">文本效果：加粗与斜体与中划线</h2><p><strong>在一段文本的起始和终止位置分别添加两个星号，如本行文字即是在编辑器中如此操作后的加粗效果。</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**在一段文本的起始位置和终止位置分别添加两个星号**</span></span><br><span class="line">或者</span><br><span class="line"><span class="strong">__使用下划线也可以实现相同的效果__</span></span><br></pre></td></tr></table></figure><p><em>斜体方式与文本加粗同理，但改为使用一个星号或一个下划线。</em></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*这是一行斜体文字*</span></span><br><span class="line"><span class="emphasis">_这也是一行斜体_</span></span><br></pre></td></tr></table></figure><p><del>中划线（删除线）则使用两个波浪号</del></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~这是一行删除线文字~~</span><br></pre></td></tr></table></figure><p><del><em><strong>如果要实现同时加粗和斜体和中划线，则将星号或者下划线的数量改成三个，再外加两个波浪号即可（叠加原理）</strong></em></del></p><h2 id="段落间分割线">段落间分割线</h2><p>三个及以上的星号*或者下划线_即可</p><hr /><p>如此处所示</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">天青色等烟雨</span><br><span class="line"><span class="strong">____</span>(或者<span class="strong">****</span>) </span><br><span class="line">而我在等你</span><br></pre></td></tr></table></figure><h2 id="列表编写">列表编写</h2><h3 id="无序列表">无序列表</h3><ul><li>列表的符号是*或者+或者-（后面加一个空格再接文本）</li><li>一般编辑器中，同一个列表（每一项紧邻）的每一项前面添加的列表符号必须相同，否则会被渲染成两个不同的列表（间隔较大）</li><li>Typora中，同一列表里一项末尾直接enter可以产生下一项，再次enter会消除自动添加的列表格式。使用不同的列表符号也不会有换列表效果，只能再加一个enter手动产生行距再添加新列表。（有序列表同理）</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> 第一项任务</span><br><span class="line"><span class="bullet">*</span> 第二项任务</span><br><span class="line"><span class="bullet">*</span> 第三项任务</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 另一个列表第一项</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> 这又是一个新的列表</span><br></pre></td></tr></table></figure><h3 id="有序列表">有序列表</h3><ol type="1"><li>列表第一项用“数字 + . +空格”</li><li>后续换行就会自动产生第二项</li><li>顺序是由列表第一项决定的，后面每一项的序号都自动递增。</li></ol><h3 id="列表嵌套">列表嵌套</h3><ul><li><p>一级列表下直接编写文本的方法：enter换行+回车，再编写文本即可。</p></li><li><p>在一级列表里嵌套二级列表的方式：在一级列表的某一项后换行，回车删除自动添加的一级序号，再用“数字+ . + 空格”或者“* +空格”，即可实现该项下创建二级有序或无序列表（后面介绍的复选框列表也可以这样嵌套）。</p></li><li><p>若要跳出二级列表循环，重新创建上一级列表的下一项，则连续按下三次enter即可（连续两次是消除二级列表格式，直接在一级列表的该项下编写普通文本，编写文本后需要再连续按两次enter才能跳出一级列表的该项，新建一级列表的下一项）</p></li></ul><p>示例：</p><ol type="1"><li><p>一级列表第一项（然后enter换行+回车，直接在该项下编写文本）</p><p>一级列表下的一段文本。（一个enter+“1 + . +空格”,继续创建二级有序列表）</p><ol type="1"><li><p>二级列表第一项（一个enter创建同级下一项）</p></li><li><p>二级列表第二项（enter换行+回车，直接在该项下编写文本）</p><p>二级列表下编写一段文本。（两次enter消除二级列表下的文本格式，创建二级列表下一项）</p></li><li><p>二级列表第三项</p></li></ol></li><li><p>一级列表第二项（enter换行+回车+“1 + . + 空格”创建二级列表）</p><ol type="1"><li>二级列表第一项（连续三次enter跳出二级列表循环创建一级列表下一项）</li></ol></li><li><p>一级列表第三项</p><ol type="1"><li>二级列表第一项（两次enter消除二级列表格式，直接在一级列表该项下编写文本）</li></ol><p>一级列表下的一段文本。（再连续两次enter跳出一级列表该项，新建一级列表下一项）</p></li><li><p>一级列表第四项</p></li></ol><h3 id="勾选框">勾选框</h3><ul class="task-list"><li><label><input type="checkbox"checked="" />第一项任务已完成</label></li><li><label><input type="checkbox" />第二项任务未完成</label></li></ul><p>像这样的勾选框列表如何实现呢？(勾选框是否可勾选和html渲染插件有关)</p><p>操作方法是在无序列表符号*后面跟上“空格+[空格填充]+空格”，若[]内用字母x填充则变为选中状态，用空格填充则为非选中状态。</p><h2 id="代码块">代码块</h2><p>Typora里可以直接右键调用插件插入代码块，一般通用的方法是在需要设置为代码块的段落前一行和后一行分别添加```</p><p>第一行```后面跟代码块格式（c++，java等）</p><p>如下所示</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```c++(在```</span>后面跟代码块格式)</span><br><span class="line">代码段落</span><br><span class="line">代码段落</span><br><span class="line">代码段落</span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure><p>如果要在行内插入小代码块<code>小代码块</code>，则在要设为小代码块的内容前后分别添加`</p><p>如下所示</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一行<span class="code">`markdown`</span>代码块。</span><br></pre></td></tr></table></figure><p>小代码块的使用场景一般有两种：</p><ol type="1"><li>需要在行内插入代码辅助解释。</li><li>有特殊符号，为保留原文本，避免被解析成某种语法或者链接，可以将其用代码块包裹。</li></ol><p>PS：如果需要直接插入网页URL，为不被解析为其他符号且能点击跳转，同时避免URL后的文本也被解析为链接的一部分，可以使用<code>&lt;&gt;</code>符号包裹URL，第一个&lt;表示链接开始，第二个&gt;表示链接结束。</p><h2 id="引用">引用</h2><p>在每一行要引用的内容开头加符号&gt;和空格即可</p><p>若要嵌套，使用多个<code>&gt;</code>符号即可</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 这是一段引用的文本，来自某公众号文章</span></span><br><span class="line"><span class="quote">&gt; - 引用里面也可以嵌套其他格式如列表，代码块和二级引用</span></span><br><span class="line"><span class="quote">&gt; - 引用部分内的其他语法都可嵌套，其他格式内也可以嵌套引用，将符号顺序改一下即可。</span></span><br><span class="line"><span class="bullet">-</span> &gt; 比如这里就是在一个列表里插入引用</span><br><span class="line">  &gt;&gt;在引用里嵌套引用</span><br></pre></td></tr></table></figure><blockquote><p>这是一段引用的文本，来自某公众号文章</p><ul><li>引用里面也可以嵌套其他格式如列表，代码块和二级引用</li><li>引用部分内的其他语法都可嵌套，其他格式内也可以嵌套引用，将符号顺序改一下即可。</li></ul></blockquote><ul><li><blockquote><p>比如这里就是在一个列表里插入引用</p><blockquote><p>在引用里嵌套引用</p></blockquote></blockquote></li></ul><h2 id="超链接">超链接</h2><p>普通超链接使用<code>[]()</code>符号，填充规则如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[要跳转的目标名称，如我的个人网站](网站域名)</span><br><span class="line">示例：</span><br><span class="line">[我的博客](ccloire.com)</span><br><span class="line">之后就会渲染为一行可点击跳转的加粗“我的博客”文本，点击即可跳转到ccloire.com网站</span><br></pre></td></tr></table></figure><p>域名分离超链接：</p><p>若域名太长且多处需要调用网页超链接，则为了编写时更加简洁高效，也可以采用重命名的方式</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[我的博客][a]里面有我的个人技术文章，欢迎大家光临，也可以去[代码随想录][b]里查找算法练习。</span><br><span class="line">别名还可以反复使用，如[柯北的技术博客][a]渲染后也是跳转到https://ccloire.com的超链接</span><br><span class="line"></span><br><span class="line">[a]: https://ccloire.com</span><br><span class="line">[b]: https://algorithm.com</span><br></pre></td></tr></table></figure><h2 id="脚注">脚注</h2><p>感兴趣的读者可以前往我的个人网站<a href="#fn1" class="footnote-ref"id="fnref1" role="doc-noteref"><sup>1</sup></a></p><p>像这样给一段文本加注释角标，鼠标点击时跳转注释（若有网页链接也可以直接点击跳转）的方式如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">个人网站[^1],第二个脚注[^2]</span><br><span class="line"></span><br><span class="line">[^1]:网站有两个https://ccloire.com或https://ccloire2.com</span><br><span class="line">[^2]:随便什么内容</span><br></pre></td></tr></table></figure><h2 id="插入图像">插入图像</h2><img src="https://caimotu.top/Picgo/微信图片_20250226100519.jpg" alt="样例图" style="zoom:50%;" /><ul><li><p>常规语法：</p><p>像这样插入图片的常规语法是<code>![图片名称](图片路径)</code>，图片路径可以是本地路径---但只能在本机访问该图片；也可以是URL链接指向网址中的图片---能联网就能访问。</p></li><li><p>快捷方法：</p><p>在Typora中，安装插件即可支持右键选择插入图像功能，自动补充图像语法，用户只需点击文件夹图标在本地选择要上传的图片或者手动输入图片链接即可。插件网盘链接：<ahref="https://pan.baidu.com/s/1h19j_es-iW4GVrkmUWIL7g?pwd=3251">https://pan.baidu.com/s/1h19j_es-iW4GVrkmUWIL7g?pwd=3251</a>，有需要的读者自取，提取码3251。也可以扫码领取：<imgsrc="https://caimotu.top/Picgo/image-20250331132048320.png"alt="image-20250331132048320" /></p><p>插件安装方法：将插件文件夹下的plugin文件夹复制粘贴到这个目录下：D:\ProgramFiles\Typora\resources（D:\ProgramFiles是我的Typora安装位置，具体以读者的实际安装位置为准），然后运行<code>plugin\bin\install_windows_amd_x64.exe</code>，这个脚本会修改Typora\resources目录下的windows.html文件，使得插件在Typora中正常运行。</p><p>插件使用说明见官网文档：<ahref="https://github.com/obgnail/typora_plugin?tab=readme-ov-file#%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E">https://github.com/obgnail/typora_plugin?tab=readme-ov-file#%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E</a></p></li><li><p>本地图片转化为网页链接的方法---搭建个人图床：详见本站的另一篇文章</p></li><li><p>图片的缩放---使用HTML语法：</p><p>markdown编辑器一般都支持部分HTML格式，因此我们可以用如下语法来插入图片并调整其大小</p><p><code>&lt;img style="width: 500px;height: 300px" src="https://caimotu.top/Picgo/image-20250331132048320.png" alt ="示例图片" /&gt;</code>。</p><p><code>style</code>变量指定了图片的大小风格，<code>src</code>变量指定了图片的URL链接，<code>alt</code>变量指定了渲染后图片下方的注释名称（但不是所有网页和编辑器都会显示这个alt名称）。</p><p>PS:Typora插件支持右键直接修改图片缩放比例，将markdown语法转换为HTML语法。</p></li></ul><h2 id="插入视频">插入视频</h2><p>插入外部网站的视频需要使用HTML语法，常用的方式是<code>&lt;iframe&gt;</code>标签，示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;https://www.bilibili.com/video/BV1vtoXY9E7v?vd_source=4b639497636747eb9e7ebb76d4d0b7cf&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">&quot;width: 100%; height: auto; aspect-ratio: 16/9; border: 20px solid black&quot;</span>   #<span class="attr">视频格式</span></span></span><br><span class="line"><span class="tag">        (<span class="attr">其中border表示边框样式</span>，<span class="attr">aspect-ratio表示视频比例</span>)</span></span><br><span class="line"><span class="tag">        <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span>   #<span class="attr">是否允许滚动</span></span></span><br><span class="line"><span class="tag">        <span class="attr">frameborder</span>=<span class="string">&quot;yes&quot;</span>   #<span class="attr">是否设置边框</span></span></span><br><span class="line"><span class="tag">        <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>   #<span class="attr">允许全屏播放</span></span></span><br><span class="line"><span class="tag">        <span class="attr">title</span>=<span class="string">&quot;bilibili视频&quot;</span>   #<span class="attr">视频标题</span></span></span><br><span class="line"><span class="tag">        &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以下示例视频展示效果</p><iframe         src="//player.bilibili.com/player.html?isOutside=true&aid=114087434454472&bvid=BV11RXRYuEdL&cid=28640083971&p=1"        style="width: 100%; height: auto; aspect-ratio: 16/9; border: 20px solid black"         scrolling="no"         frameborder="yes"         framespacing="0"        allowfullscreen="true"        title="bilibili视频"        ></iframe><h2 id="插入表格">插入表格</h2><p>markdown中添加表格的方式是很形象的，使用<code>|</code>和<code>-</code>两个符号构成表格的形状即可。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|   | 姓名 | 年龄 | 性别 |      </span><br><span class="line">| - | --- | ---- | --- |      </span><br><span class="line">| 1 | 小明 |  18  | 男  |     </span><br><span class="line">| 2 | 小红 |  18  | 女  |                                   </span><br></pre></td></tr></table></figure><p>“|”后面接一个空格再跟表头内容，“-”表示表头和项之间的分割线，一个“-”即可正常渲染，使用多个“-”是为了编辑上与表格形状尽量贴近，便于查看。</p><p>如果要控制每一列内容的对齐格式，可以在分割线的“-”两边添加“:”</p><p>左边添加表示左对齐，右边添加表示右对齐，两边同时添加表示居中。</p><p>PS： Typora中的插件也可以实现一键插入表格和一键编辑。</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;">姓名</th><th style="text-align: center;">年龄</th><th style="text-align: center;">性别</th></tr></thead><tbody><tr><td style="text-align: center;">1</td><td style="text-align: center;">小明</td><td style="text-align: center;">18</td><td style="text-align: center;">男</td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;">小红</td><td style="text-align: center;">18</td><td style="text-align: center;">女</td></tr></tbody></table><h2 id="其他拓展语法">其他拓展语法：</h2><img src="https://caimotu.top/Picgo/image-20250402173231226.png" alt="image-20250402173231226" style="zoom:50%;" /><p>Typora支持上图展示的几种拓展语法。</p><p>对于内联公式，此处展示一些常用的Latex语法：</p><ul><li><p>单独一行Latex数学公式用左右各一个<code>$</code>包裹，比如<code>$y = x + 10$</code>，渲染后就是<span class="math inline">\(y = x + 10\)</span></p></li><li><p>若要编写一段多行公式，可以在公式段前后添加<code>$$</code>，内部使用<code>\begin&#123;split&#125; A\\B \end&#123;split&#125;</code>进行换行，<code>\\</code>要写在行与行之间，这是因为Mathjax渲染器的局限（无法直接识别单独的<code>\\</code>换行）；hexo-filter-mathjax插件会对每个<code>$$</code>公式段自动编号。<br />示例如下：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;split&#125;</span><br><span class="line">y = x + 10</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line">y = x - 10</span><br><span class="line"><span class="keyword">\end</span>&#123;split&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure></li></ul><p>​ 渲染后为： <span class="math display">\[\begin{split}y = x + 10\\y = x - 10\end{split}\]</span></p><ul><li><p>分式语法：<code>\frac&#123;分子&#125;&#123;分母&#125;</code>，示例：<spanclass="math inline">\(\frac{1}{10}\)</span></p></li><li><p>上下标：除了上图中<code>~下标~</code>和<code>^上标^</code>的写法外，还可以直接在内联公式段里使用单独的下划线_表示下标，单独的^表示上标。</p><p>而且Latex语法支持同时使用上下标，如<code>x_2^&#123;2x&#125;</code>，渲染后效果:<span class="math inline">\(x_2^{2x}\)</span></p></li><li><p>开根号：<code>\sqrt[4]&#123;3&#125;</code>表示给3开四次根：<spanclass="math inline">\(\sqrt[4]{3}\)</span></p><p>如果要给一串代数式开根，又不想代数式中的某些<code>&#123;&#125;</code>符号被解析成语法格式，可以使用转义符<code>\</code>，如<code>$\sqrt[4]&#123;\&#123;(4+x) - 3\&#125;&#125;$</code>，渲染后为：<spanclass="math inline">\(\sqrt[4]{\{4+x)-3\}}\)</span></p></li><li><p>常见数学符号：</p><ol type="1"><li>不等于：<code>\not=</code> <spanclass="math inline">\(\not=\)</span></li><li>与等于：<code>\approx</code> <spanclass="math inline">\(\approx\)</span></li><li>小于等于：<code>\leq</code> <spanclass="math inline">\(\leq\)</span></li><li>大于等于：<code>\geq</code> <spanclass="math inline">\(\geq\)</span></li><li>乘号：<code>\times</code> <spanclass="math inline">\(\times\)</span></li><li>除号：<code>\div</code>或者<code>\textdiv</code> <spanclass="math inline">\(\div\)</span></li><li>正负号：<code>\pm</code> <spanclass="math inline">\(\pm\)</span></li><li>求和符号(配合上下标)：<code>\sum^2_2</code> <spanclass="math inline">\(\sum^2_2\)</span></li><li>累乘：<code>\prod</code> <spanclass="math inline">\(\prod\)</span></li><li>度数： <code>90^\circ</code> <spanclass="math inline">\(90^\circ\)</span></li><li>三角函数：<code>\sin\pi</code> <spanclass="math inline">\(\sin\pi\)</span> 其余同理</li><li>无穷：<code>\infty</code> <spanclass="math inline">\(\infty\)</span></li><li>定积分：<code>\int^b_ax^2dx</code> <spanclass="math inline">\(\int^b_ax^2dx\)</span> (PS：n重积分就用n个i，如三重积分<code>\iiint</code><spanclass="math inline">\(\iiint\)</span>)</li><li>求导符号：<code>y\prime</code> <spanclass="math inline">\(y\prime\)</span></li><li>元素属于/不属于集合：<code>x\in A</code>以及<code>x\notin A</code><span class="math inline">\(x\in A\)</span> 以及 <spanclass="math inline">\(x\notin A\)</span></li><li>极限：<code>\lim_&#123;n\rightarrow+\infty&#125;\frac&#123;1&#125;&#123;n&#125;</code> <spanclass="math inline">\(\lim_{n\rightarrow+\infty}\frac{1}{n}\)</span>​</li><li>省略号：<code>\frac&#123;1&#125;&#123;2&#125;+\frac&#123;1&#125;&#123;3&#125;+\cdots+\frac&#123;1&#125;&#123;n&#125;</code><spanclass="math inline">\(\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{n}\)</span>​</li></ol></li></ul><p>更多markdown中编写Latex语法的内容可以查看<ahref="https://www.cmor-faculty.rice.edu/~heinken/latex/symbols.pdf">莱斯大学LatexMath在线手册</a></p><p>还可以翻阅一位up的帖子，介绍的也很全面<ahref="https://zhuanlan.zhihu.com/p/59412540">来自李东的知乎帖子</a>。</p><h2 id="使用内置的mermaid插件画图">使用内置的mermaid插件画图</h2><p>markdown格式支持对使用mermaid绘制的图表进行渲染，只要在markdown编辑器中安装mermaid拓展插件即可。Typora本身就集成了mermaid环境，因此可以直接在代码块中声明语法为mermaid并进行绘图。</p><blockquote><p>PS：mermaid最新版目前已经更新到11.6以后了，而各大markdown编辑器如Typora不一定有对最新版mermaid插件的支持。且某些Typora破解版也只能激活旧版本，对mermaid插件支持也比较低级。故实际使用时有些mermaid语法可能无法正常渲染，读者有需要可以去<ahref="https://mermaid.js.org/">mermaid官网</a>使用最新版本，官网内也附带非常详细的<ahref="https://mermaid.js.org/ecosystem/tutorials.html">mermaid部署，语法以及配置教程</a>。</p><p>对于写博客的同志，有可能你的博客配置进行了最新版本mermaid的部署（比如我使用的是hexo-theme-butterfly，主题适配了11.4.1版本的mermaid），这种情况你可以在Typora里用源代码模式编写mermaid，以实际博客网站渲染出来的效果为准。当然如果你更习惯Typora这种即使渲染的效果，且想以Typora里的编辑为准，那就只能接受一些版本局限。</p></blockquote><p>下面介绍一些常用且通用的mermaid基础语法。</p><h3 id="流程图">流程图</h3><p>Typora中集成了两种绘制流程图的插件，一个就是mermaid，另一个是较为简单的flow（只能绘制流程图）</p><p>下面介绍这两种插件绘制流程图的方法（在代码块中声明语法为mermaid或flow）：</p><h4 id="flow插件绘制">flow插件绘制</h4><div id="flowchart-0" class="flow-chart"></div><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始     //st表示结点命名，“=&gt;start: 开始”表示指结点类型和填充内容</span><br><span class="line">on=&gt;operation: 执行内容</span><br><span class="line">cn=&gt;condition: 执行是否成功</span><br><span class="line">en=&gt;end: 结束</span><br><span class="line">st-&gt;on        //&quot;-&gt;&quot;表示结点之间的有向线段</span><br><span class="line">on-&gt;cn(yes)-&gt;en      //condition类结点可以指定条件为&quot;yes&quot; or &quot;no&quot;</span><br><span class="line">cn(no)-&gt;on</span><br></pre></td></tr></table></figure><h4 id="mermaid插件绘制">mermaid插件绘制</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TB;</span><br><span class="line">  A--&gt;B</span><br><span class="line">  B--&gt;C</span><br><span class="line">  C--&gt;A</span><br><span class="line">%% mermaid注释内容（%%注释不会被识别为图表语法）</span><br></pre></td></tr></table></figure><pre><code class="highlight mermaid">graph TB;  A--&gt;B  B--&gt;C  C--&gt;A</code></pre><p>语法简析：</p><ul><li><p>graph表示流程图的开始，TB表示箭头方向从上到下，A--&gt;B表示A结点指向B结点。</p><p>结点没有声明类型和内容时默认为矩形结点，并以编号填充。</p></li><li><p>其他的箭头方向还有：</p></li></ul><table><thead><tr><th>用词</th><th>含义</th></tr></thead><tbody><tr><td>TB</td><td>从上到下</td></tr><tr><td>BT</td><td>从下到上</td></tr><tr><td>RL</td><td>从右到左</td></tr><tr><td>LR</td><td>从左到右</td></tr></tbody></table><ul><li>下面是mermaid流程图常见的符号及含义：</li></ul><table><thead><tr><th>用词</th><th>说明</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td>node_id[结点内容]</td><td>矩形结点</td><td style="text-align: left;">表示过程，即流程中的某个环节</td></tr><tr><td>node_id(结点内容)</td><td>圆角矩形结点</td><td style="text-align: left;">表示开始或结束</td></tr><tr><td>node_id((结点内容))</td><td>圆形结点</td><tdstyle="text-align: left;">表示链接，用于流程过长或有交叉的情形，将流程分成两部分</td></tr><tr><td>node_id{结点内容}</td><td>菱形结点</td><td style="text-align: left;">表示条件判断或决策</td></tr><tr><td>node_id&gt;结点内容]</td><td>右向旗帜状结点</td><td style="text-align: left;"></td></tr></tbody></table><pre><code class="highlight mermaid">graph A[矩形结点] B(圆角矩形节点)C((圆形结点))D&#123;菱形结点&#125;E&gt;右向旗帜状结点]</code></pre><ul><li><p>下面是常见的连线类型：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">  A1--&gt;B1</span><br><span class="line">  A2---B2</span><br><span class="line">  A3--text---B3</span><br><span class="line">  A4--text--&gt;B4</span><br><span class="line">  A5-.-B5</span><br><span class="line">  A6-.-&gt;B6</span><br><span class="line">  A7-.text.-B7</span><br><span class="line">  A8-.text.-&gt;B8</span><br><span class="line">  A9===B9</span><br><span class="line">  A10==&gt;B10</span><br><span class="line">  A11==text===B11</span><br><span class="line">  A12==text==&gt;B12</span><br></pre></td></tr></table></figure><pre><code class="highlight mermaid">graph TB  A1--&gt;B1  A2---B2  A3--text---B3  A4--text--&gt;B4  A5-.-B5  A6-.-&gt;B6  A7-.text.-B7  A8-.text.-&gt;B8  A9===B9  A10==&gt;B10  A11==text===B11  A12==text==&gt;B12</code></pre></li><li><p>子图表的绘制：</p><p>mermaid画流程图可以在一个图表里嵌套子图表，来实现独立模块的划分。</p><p>子图表的箭头方向可以单独指定，但如果子图表的结点和外部产生链接，则子图表的箭头方向会失效，取而代之的是继承父类图表的方向。</p><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"><span class="code">subgraph 子图表-工作流 </span></span><br><span class="line"><span class="code">direction LR</span></span><br><span class="line"><span class="code">    begin(打开电脑)--&gt;work[敲代码干活]</span></span><br><span class="line"><span class="code">end</span></span><br><span class="line"><span class="code">stop&#123;休息会&#125;</span></span><br><span class="line"><span class="code">work--&gt;temp&#123;干活满45分钟没&#125;--&gt;|no| work</span></span><br><span class="line"><span class="code">temp --&gt;|yes| stop--&gt;|休息满10分钟| work</span></span><br><span class="line"><span class="code">stop--&gt;|没满十分钟| stop</span></span><br></pre></td></tr></table></figure><pre><code class="highlight mermaid">graph TBsubgraph 子图表-工作流 direction LR    begin(打开电脑)--&gt;work[敲代码干活]endstop&#123;休息会&#125;work--&gt;temp&#123;干活满45分钟没&#125;--&gt;|no| worktemp --&gt;|yes| stop--&gt;|休息满10分钟| workstop--&gt;|没满十分钟| stop</code></pre></li></ul><h3 id="序列图">序列图</h3><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line"><span class="code">Title: 谈恋爱</span></span><br><span class="line"><span class="code">男孩-&gt;&gt;女孩: 我喜欢你</span></span><br><span class="line"><span class="code">女孩--&gt;&gt;男孩: 你是个好人</span></span><br></pre></td></tr></table></figure><pre><code class="highlight mermaid">sequenceDiagramTitle: 谈恋爱男孩-&gt;&gt;女孩: 我喜欢你女孩--&gt;&gt;男孩: 你是个好人</code></pre><p>语法解析：</p><h4 id="参与者">参与者：</h4><p>参与者表示序列图中一切可以交互的事物，可以是人，类对象或系统。而每个参与者上下之间的竖线表示时间的流逝。</p><p>声明参与者的语法为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line"><span class="code">    participant 参与者1</span></span><br><span class="line"><span class="code">    participant 参与者2</span></span><br><span class="line"><span class="code">    ...</span></span><br><span class="line"><span class="code">    participant 简称 as 参与者n  //此写法可以在后文用简称代替“参与者n”</span></span><br></pre></td></tr></table></figure><h4 id="消息线">消息线</h4><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>-&gt;</td><td>无箭头的实线</td></tr><tr><td>--&gt;</td><td>无箭头的虚线</td></tr><tr><td>-&gt;&gt;</td><td>带箭头的实线</td></tr><tr><td>--&gt;&gt;</td><td>带箭头的虚线</td></tr><tr><td>-x</td><td>末端为x的实线（表示异步执行）</td></tr><tr><td>--x</td><td>末端为x的虚线（表示异步执行）</td></tr></tbody></table><h4 id="处理中激活框">处理中—激活框</h4><p>在参与者的时间线上标记一个激活框，表示对某一条消息进行处理的时间间隔</p><p>在消息线末尾，消息接收方前添加一个“+”，则消息接收者进入对该消息的“处理中”状态。</p><p>在消息线末尾，消息接收方前添加一个“-”，则消息接收者离开对该消息的“处理中”状态。</p><h4 id="注释">注释</h4><p>注释格式为：<code>Note 位置表述 参与者: 注释内容</code></p><p>位置表述有：</p><ul><li>right of ：右侧</li><li>left of ：左侧</li><li>over ：横跨在多个参与者之中</li></ul><h4 id="循环">循环</h4><p>满足一定条件时，重复发出消息序列。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop 执行条件</span><br><span class="line"><span class="code">要执行的消息序列</span></span><br><span class="line"><span class="code">end</span></span><br></pre></td></tr></table></figure><h4 id="选择">选择</h4><p>类似else-if这样的条件判断语句：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alt 条件1</span><br><span class="line"><span class="code">执行语句1</span></span><br><span class="line"><span class="code">else 条件2</span></span><br><span class="line"><span class="code">执行语句2</span></span><br><span class="line"><span class="code">else 条件3</span></span><br><span class="line"><span class="code">执行语句3</span></span><br><span class="line"><span class="code">end</span></span><br></pre></td></tr></table></figure><h4 id="并行">并行</h4><p>par并行序列表示多个动作同时进行：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">par 并行序列名称</span><br><span class="line"><span class="code">执行语句1</span></span><br><span class="line"><span class="code">and </span></span><br><span class="line"><span class="code">执行语句2</span></span><br><span class="line"><span class="code">end</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line"><span class="code">Title: 买炸鸡</span></span><br><span class="line"><span class="code">participant A as Loire</span></span><br><span class="line"><span class="code">participant B as 炸鸡店老板</span></span><br><span class="line"><span class="code">Note left of A: 18岁</span></span><br><span class="line"><span class="code">Note right of B: 38岁</span></span><br><span class="line"><span class="code">Note over A,B: 人民广场的一个午后</span></span><br><span class="line"><span class="code">loop 十秒钟一次，执行30秒</span></span><br><span class="line"><span class="code">A -x +B: 我炸鸡好了吗</span></span><br><span class="line"><span class="code">B --&gt;&gt; -A: 还在炸</span></span><br><span class="line"><span class="code">end</span></span><br><span class="line"><span class="code">A --x +B: 还要炸多久</span></span><br><span class="line"><span class="code">B --&gt;&gt; -A: 还有x分钟</span></span><br><span class="line"><span class="code">alt x &gt; 20</span></span><br><span class="line"><span class="code">A -&gt;&gt; B: 我不要了</span></span><br><span class="line"><span class="code">else x &lt; 20 &amp;&amp; x &gt; 10</span></span><br><span class="line"><span class="code">A -&gt;&gt; B: 炸的真慢</span></span><br><span class="line"><span class="code">else x &lt; 10</span></span><br><span class="line"><span class="code">A -&gt;&gt; B: 好的</span></span><br><span class="line"><span class="code">end</span></span><br><span class="line"><span class="code">par 悠闲地炸鸡</span></span><br><span class="line"><span class="code">B -&gt;&gt; B: 哼歌</span></span><br><span class="line"><span class="code">and </span></span><br><span class="line"><span class="code">B -&gt;&gt; B: 包装炸鸡</span></span><br><span class="line"><span class="code">end</span></span><br><span class="line"><span class="code">B --&gt;&gt; A: 炸鸡好了</span></span><br></pre></td></tr></table></figure><pre><code class="highlight mermaid">sequenceDiagramTitle: 买炸鸡participant A as Loireparticipant B as 炸鸡店老板Note left of A: 18岁Note right of B: 38岁Note over A,B: 人民广场的一个午后loop 十秒钟一次，执行30秒A -x +B: 我炸鸡好了吗B --&gt;&gt; -A: 还在炸endA --x +B: 还要炸多久B --&gt;&gt; -A: 还有x分钟alt x &gt; 20A -&gt;&gt; B: 我不要了else x &lt; 20 &amp;&amp; x &gt; 10A -&gt;&gt; B: 炸的真慢else x &lt; 10A -&gt;&gt; B: 好的endpar 悠闲地炸鸡B -&gt;&gt; B: 哼歌and B -&gt;&gt; B: 包装炸鸡endB --&gt;&gt; A: 炸鸡好了</code></pre><h3 id="饼图">饼图</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pie    //声明饼图</span><br><span class="line"><span class="code">title 编程语言流行度   //饼图标题</span></span><br><span class="line"><span class="code">&quot;C++&quot; : 200    //组成部分以及其数量（最多支持两位小数）</span></span><br><span class="line"><span class="code">&quot;Java&quot; : 120</span></span><br><span class="line"><span class="code">&quot;Go&quot; : 80</span></span><br></pre></td></tr></table></figure><pre><code class="highlight mermaid">pietitle 编程语言流行度&quot;C++&quot; : 200&quot;Java&quot; : 120&quot;Go&quot; : 80</code></pre><h3 id="甘特图">甘特图</h3><p>甘特图的基本构成如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gantt   //声明甘特图</span><br><span class="line"><span class="code">title 标题</span></span><br><span class="line"><span class="code">dataFormat 日期格式（指甘特图下方时间线的日期格式，一般用YYYY-MM-DD）</span></span><br><span class="line"><span class="code">    excludes 不工作的时间段</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    section 任务名</span></span><br><span class="line"><span class="code">    任务名: 参数1，参数2，参数3，参数4，参数5，参数6</span></span><br></pre></td></tr></table></figure><ul><li><p>excludes:后跟具体日期（2025-01-01）、星期（sunday）、周末（weekends）或前三个日期格式的组合，表示该日期期间不安排工作。比如某个任务开始时间是周五，持续3天，而excludes限定周末不工作，则任务将持续到下周二才完成。</p></li><li><p>参数1：填crit表示重要事件（红色框效果）或者milestone不填。</p></li><li><p>参数2：done(已完成，灰色效果)、active(正在进行，浅蓝色效果)、不填（待完成状态，深蓝色效果）。</p></li><li><p>参数3：milestone(表示里程碑事件；菱形效果；若任务被声明为里程碑，持续时间应该设为0d，或者开始和结束在同一天)、不填。</p></li><li><p>参数4：别名或者不填。</p></li><li><p>参数5：任务开始时间，可以是具体日期(YYYY-MM-DD)，也可以是aftertask(task为同一个section里的其他任务名或者其别名)。</p></li><li><p>参数6：任务结束时间，可以是具体结束日期，也可以是从开始时间算起的持续时间(如3d，20h)。</p></li><li><p>PS：参数5和参数6是必填的，但是也可以两个参数统一一个参量表示(如3d，20h)，表示默认从上一个任务的结束时间开始，持续多长时间。</p></li></ul><p>甘特图示例如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line"><span class="code">    dateFormat  YYYY-MM-DD</span></span><br><span class="line"><span class="code">    title       Adding GANTT diagram functionality to mermaid</span></span><br><span class="line"><span class="code">    excludes    weekends</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    section A section</span></span><br><span class="line"><span class="code">    Completed task            :done,    des1, 2014-01-06,2014-01-08   </span></span><br><span class="line"><span class="code">    %% 以上任务的参数没有出现crit，说明第一个参数不填，不是重要任务；done表示已完成，des1表示别名，后面是开始和结束时间</span></span><br><span class="line"><span class="code">    Active task               :active,  des2, 2014-01-09, 3d</span></span><br><span class="line"><span class="code">    Future task               :         des3, after des2, 5d</span></span><br><span class="line"><span class="code">    %% 前两个参数不填，表示待完成；after des2表示在Active task结束后开始，5d表示持续5天</span></span><br><span class="line"><span class="code">    Future task2              :         des4, after des3, 5d</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    section Critical tasks</span></span><br><span class="line"><span class="code">    Completed task in the critical line :crit, done, 2014-01-06,24h</span></span><br><span class="line"><span class="code">    Implement parser and jison          :crit, done, after des1, 2d</span></span><br><span class="line"><span class="code">    Create tests for parser             :crit, active, 3d</span></span><br><span class="line"><span class="code">    Future task in critical line        :crit, 5d</span></span><br><span class="line"><span class="code">    %% 时间参数只有5d，表示默认从“Create tests for parser”任务的结束时间开始，持续5天</span></span><br><span class="line"><span class="code">    Create tests for renderer           :2d</span></span><br><span class="line"><span class="code">    Functionality added                 :milestone, isadded, 2014-01-25, 0d</span></span><br><span class="line"><span class="code">    %% 里程碑事件，起始时间+0d表示一天内发生</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    section Documentation</span></span><br><span class="line"><span class="code">    Describe gantt syntax               :active, a1, after des1, 3d</span></span><br><span class="line"><span class="code">    Add gantt diagram to demo page      :after a1  , 20h</span></span><br><span class="line"><span class="code">    Add another diagram to demo page    :doc1, after a1  , 48h</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    section Last section</span></span><br><span class="line"><span class="code">    Describe gantt syntax               :after doc1, 3d</span></span><br><span class="line"><span class="code">    Add gantt diagram to demo page      :20h</span></span><br><span class="line"><span class="code">    Add another diagram to demo page    :48h</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure><pre><code class="highlight mermaid">gantt    dateFormat  YYYY-MM-DD    title       Adding GANTT diagram functionality to mermaid    excludes    weekends    %% (`excludes` accepts specific dates in YYYY-MM-DD format, days of the week (&quot;sunday&quot;) or &quot;weekends&quot;, but not the word &quot;weekdays&quot;.)    section A section    Completed task            :done,    des1, 2014-01-06,2014-01-08    Active task               :active,  des2, 2014-01-09, 3d    Future task               :         des3, after des2, 5d    Future task2              :         des4, after des3, 5d    section Critical tasks    Completed task in the critical line :crit, done, 2014-01-06,24h    Implement parser and jison          :crit, done, after des1, 2d    Create tests for parser             :crit, active, 3d    Future task in critical line        :crit, 5d    Create tests for renderer           :2d    Functionality added                 :milestone, isadded, 2014-01-25, 0d    section Documentation    Describe gantt syntax               :active, a1, after des1, 3d    Add gantt diagram to demo page      :after a1  , 20h    Add another diagram to demo page    :doc1, after a1  , 48h    section Last section    Describe gantt syntax               :after doc1, 3d    Add gantt diagram to demo page      :20h    Add another diagram to demo page    :48h</code></pre><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始on=>operation: 执行内容cn=>condition: 执行是否成功en=>end: 结束st->onon->cn(yes)->encn(no)->on</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><section id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p>网站有两个<ahref="https://ccloire.com">https://ccloire.com</a>或<ahref="https://ccloire2.com">https://ccloire2.com</a><a href="#fnref1"class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
      
      
    <summary type="html">&lt;h1
id=&quot;markdown语法总结&quot;&gt;&lt;span style=&quot;font-size:0.8em;&quot;&gt;Markdown语法总结&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;前置声明：以下大部分语法在Typora中都可以通过右键找到对应的快捷插件，学习语法一方面是方便我们灵活编辑md文本</summary>
      
    
    
    
    
    <category term="基础工具使用指南" scheme="https://ccloire.com/tags/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>如何低代码搭建个人博客？</title>
    <link href="https://ccloire.com/2025/02/26/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://ccloire.com/2025/02/26/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2025-02-26T02:22:37.000Z</published>
    <updated>2025-04-21T11:08:58.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网站搭建基本理论">网站搭建基本理论</h1><h2 id="方案介绍">方案介绍</h2><p>搭建博客可以使用现成的博客框架，也可以自行开发前后端。这里我们介绍对新手/非计算机专业学生友好的博客框架方案，可以实现低代码搭建个人博客网站。</p><p>基于hexo框架+github托管仓库+netlify提供站点部署、DNS、CDN服务搭建个人博客网站</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网站搭建基本理论&quot;&gt;网站搭建基本理论&lt;/h1&gt;
&lt;h2 id=&quot;方案介绍&quot;&gt;方案介绍&lt;/h2&gt;
&lt;p&gt;搭建博客可以使用现成的博客框架，也可以自行开发前后端。这里我们介绍对新手/非计算机专业学生友好的博客框架方案，可以实现低代码搭建个人博客网站。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="技术分享" scheme="https://ccloire.com/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://ccloire.com/2025/01/02/hello-world/"/>
    <id>https://ccloire.com/2025/01/02/hello-world/</id>
    <published>2025-01-02T10:53:34.000Z</published>
    <updated>2025-02-25T12:44:56.169Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very
first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; fo</summary>
      
    
    
    
    
  </entry>
  
</feed>
