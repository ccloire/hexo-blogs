<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>C++初级——内存空间与编译原理 | Loire's Blog</title><meta name="author" content="Loire"><meta name="copyright" content="Loire"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="PS：本C++进阶讲解基于x86 32位linux环境 进程的虚拟地址空间内存划分和布局 我们知道，任何的编程语言，在编译文件后都会产生的两种东西是指令和数据，并以可执行文件.exe的形式存储在磁盘里，而每次运行可执行文件时，都需要将磁盘上的.exe加载到内存当中，由CPU读取指令并对数据进行操作。 那么磁盘上的文件加载到内存（虚拟内存，而非直接加载到物理内存）后，如何为数据分配内存空间，内"><meta property="og:type" content="website"><meta property="og:title" content="C++初级——内存空间与编译原理"><meta property="og:url" content="https://ccloire.com/2025/08/07/C++%E5%90%88%E9%9B%86/C++%E5%88%9D%E7%BA%A7%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/index.html"><meta property="og:site_name" content="Loire&#39;s Blog"><meta property="og:description" content="PS：本C++进阶讲解基于x86 32位linux环境 进程的虚拟地址空间内存划分和布局 我们知道，任何的编程语言，在编译文件后都会产生的两种东西是指令和数据，并以可执行文件.exe的形式存储在磁盘里，而每次运行可执行文件时，都需要将磁盘上的.exe加载到内存当中，由CPU读取指令并对数据进行操作。 那么磁盘上的文件加载到内存（虚拟内存，而非直接加载到物理内存）后，如何为数据分配内存空间，内"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ccloire.com/img/butterfly-icon.png"><meta property="article:published_time" content="2025-08-07T14:13:10.000Z"><meta property="article:modified_time" content="2025-08-29T07:38:49.897Z"><meta property="article:author" content="Loire"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://ccloire.com/img/butterfly-icon.png"><script type="application/ld+json"></script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ccloire.com/2025/08/07/C++%E5%90%88%E9%9B%86/C++%E5%88%9D%E7%BA%A7%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>(()=>{const e={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:e,getScript:(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach(([e,t])=>n.setAttribute(e,t)),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),getCSS:(e,t)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const t=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},o=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=t,btf.activateLightMode=o;const a=e.get("theme");"dark"===a?t():"light"===a&&o();const n=e.get("aside-status");void 0!==n&&document.documentElement.classList.toggle("hide-aside","hide"===n);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!1},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"null",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyloadPlugin:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"C++初级——内存空间与编译原理",isHighlightShrink:!1,isToc:!1,pageType:"posts"}</script><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Loire's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章发布时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-heartbeat"></i><span> 清单</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="not-home-page" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://caimotu.top/Picgo/微信图片_20250226100519.jpg" alt="Logo"><span class="site-name">Loire's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章发布时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-heartbeat"></i><span> 清单</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="page-site-info"><h1 id="site-title">C++初级——内存空间与编译原理</h1></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>PS：本C++进阶讲解基于x86 32位linux环境</p><h2 id="进程的虚拟地址空间内存划分和布局">进程的虚拟地址空间内存划分和布局</h2><p>我们知道，任何的编程语言，在编译文件后都会产生的两种东西是指令和数据，并以可执行文件.exe的形式存储在磁盘里，而每次运行可执行文件时，都需要将磁盘上的.exe加载到内存当中，由CPU读取指令并对数据进行操作。</p><p>那么磁盘上的文件加载到内存（虚拟内存，而非直接加载到物理内存）后，如何为数据分配内存空间，内存空间的结构划分是什么样的，就需要我们详细了解。</p><p>首先，linux系统给每一个进程会分配一个<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:0" xmlns="http://www.w3.org/2000/svg" width="2.919ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 1290.1 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container></span>= 4G大小的一块虚拟内存空间（地址范围0x00000000<code>~~</code>0xFFFFFFFF）。这块空间大体分为两部分：用户空间（0x00000000<code>~~</code>0xC0000000，占3G）和内核空间（0xC0000001<code>~~</code>0xFFFFFFF，占1G）。</p><p>内存空间按地址从低到高，更具体的划分如下：</p><ol type="1"><li><p>整个内存空间的前一小块（0x00000000—0x08048000，低地址空间）是不可访问的，这片区域在现代linux操作系统中是故意留空用于保护的，防止空指针访问导致程序崩溃。如果程序试图访问虚拟地址0x0，cpu的内存管理单元会查询页表中的虚拟到物理地址映射，发现这片低地址并没有有效映射（无对应物理地址），就会发生异常中断程序进程。</p><p>e.g.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">strlen</span>(p); <span class="comment">//strlen()函数试图访问指针p指向的内存空间存放的数据并求长度，但p是指向nullptr也即零地址0x0的空指针，程序运行时会报错。</span></span><br><span class="line"><span class="type">char</span> *src = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(p,src); <span class="comment">//同理，strcpy()函数试图访问空指针src指向的内存，将其存放的数据拷贝给p，将会报错。注意p和src都是指向零地址的，但是实际内存中的低地址空间并不会真的分配给这些指针用于存放数据，只是cpu在按照nullptr查询这片低地址空间的映射并取数据或写数据时会发现查询没有结果从而报出异常。</span></span><br></pre></td></tr></table></figure></li><li><p>用户空间从0x08048000开始的第一块有效区域是<strong>.text和.rodata段</strong>。.text段也叫代码段，用于存放实际代码内容编译后对应的汇编指令。.rodata段即只读数据段，用于存放字符串字面量，其中的数据都是只能读取不能修改的。</p><p>e.g.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c风格操作，使用字符类型指针直接指向一个字符串字面量</span></span><br><span class="line"><span class="type">char</span> *p = <span class="string">"abcd"</span>; <span class="comment">//"abcd"这个字符串字面量存储在.rodata段。</span></span><br><span class="line">*p = <span class="string">"a"</span>; <span class="comment">//修改指针指向的内存空间里的数据，就是直接修改.rodata段里的"abcd"，这样做是不允许的，会在运行阶段报错。</span></span><br><span class="line"><span class="comment">//PS：目前许多高级语言已经规定普通指针不能直接指向字符串字面量，只有声明为const类型的指针才可以。这样就在编译阶段避免了修改.rodata段的数据这种错误操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C++风格操作，创建string类对象并将其赋值为一个字符串字面量</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s = <span class="string">"abcd"</span>; </span><br><span class="line"><span class="comment">//这一行代码做了三件事情，一个是在内存的栈stack上（下面有解释）创建string类对象s（这个对象内部通常包含了一些控制信息，比如一个指向字符数据的指针、字符串的当前长度和已分配内存的容量等），因为s是一个局部变量（PS：这行代码编译时会转化为汇编指令，储存在.text段）。</span></span><br><span class="line"><span class="comment">//第二个是在.rodata段创建"abcd"这个字符串字面量。</span></span><br><span class="line"><span class="comment">//最后一件事情是将"abcd"赋值给s，这步操作由string类的赋值构造函数完成，它首先会在内存的堆heap上动态分类一块大小足以容下"abcd"的内存，然后将.rodata段中的"abcd"拷贝到堆上分配的新内存里，再将对象s的内部指针指向这块堆上的新内存。</span></span><br><span class="line">s = <span class="string">"a"</span>;</span><br><span class="line"><span class="comment">//跟c风格直接更改指针指向的.rodata段数据不同，这里的操作首先在.rodata段重新创建一块内存存放字符串"a"，然后触发string类的赋值操作(operator=)，释放对象s原本分配在堆上存放"abcd"的动态内存（并不会对.rodata段里的"abcd"产生实际影响），然后重新在堆上分配一块内存，将.rodata段新创建的"a"拷贝过来，并将s内部指针指向这块内存，同时更新s长度状态。</span></span><br></pre></td></tr></table></figure></li><li><p>再往上走，就是<strong>静态区（低到高依次为.data段和.bss段）</strong>：静态区用于存放可读可写的全局/静态变量，只要程序编译好，就会在.data段存放，一直到程序结束内存清空。.data和.bss的区别在于.data存放已经初始化且不为0的数据，而.bss段存放初始化为0或者未初始化的数据（程序编译时操作系统将其自动置为0）</p><blockquote><p>PS：<strong>为什么需要 <code>.bss</code> 段？</strong> 这是一种<strong>优化</strong>。对于一个很大的、未初始化的全局数组 <code>int big_array[10000];</code>，如果把它存放在 <code>.data</code> 段，那么在可执行文件（如 ELF 文件）中就需要实实在在地占用 <code>10000 * 4</code> 字节的空间来存储这些零。而如果放在 <code>.bss</code> 段，可执行文件中<strong>只需要记录“需要分配 40000 字节，并全部置为零”这个信息</strong>，而不需要存储那些零本身。这大大减小了可执行文件的大小。</p></blockquote></li><li><p><strong>堆（heap）</strong>，用于存放动态分配的内存。</p></li><li><p><strong>加载共享库</strong>，用于存放一些动态链接库的映射（windows下为*.dll库，linux下为*so库）。</p></li><li><p><strong>栈（stack）</strong>，一个程序进程运行时可能会产生多个不同的线程（如一道程序由多个函数构成，每个函数就是一个小线程），那么每个函数在内存上占有的私有空间就是栈。也就是说，函数内部的非静态局部变量都在栈上存储。</p><blockquote><h4 id="局部变量与栈-stack">局部变量与栈 (Stack)</h4><ul><li><strong>生命周期</strong>：局部变量的生命周期与它所在的函数或代码块绑定。<strong>函数开始执行时，它被创建；函数执行结束时，它必须被销毁。</strong></li><li><strong>栈的特性</strong>：栈是一种<strong>后进先出 (LIFO)</strong> 的数据结构，这与函数的调用/返回机制完美契合。<ul><li><strong>函数调用</strong>：当一个函数被调用时，系统会在栈顶“压入”一个新的<strong>栈帧 (Stack Frame)</strong>。这个栈帧里包含了函数的参数、返回地址以及<strong>所有局部变量</strong>。</li><li><strong>函数返回</strong>：当函数执行完毕返回时，它的整个栈帧会被“弹出”，相当于瞬间释放了所有局部变量占用的空间。</li><li>对于虚拟内存的栈，地址是从高到低分配的。我们设栈顶指针esp，栈底指针ebp。当数据被压栈的时候，栈顶指针esp会向下移动一个数据大小的位置，而栈底指针不动，每次压栈都是在栈顶处（低地址）分配空间，并让栈顶指针下移。</li></ul></li><li><strong>为什么用栈？</strong><ul><li><strong>高效</strong>：栈的分配和释放只是移动一下栈顶指针 (<code>esp</code>)，这是一个极快的操作，远比在堆上动态分配内存要快。</li><li><strong>自动管理</strong>：程序员无需关心局部变量的内存释放，它随着函数返回自动完成，避免了内存泄漏。</li></ul></li></ul></blockquote></li><li><p><strong>命令行参数和环境变量</strong>（环境变量即程序调用外部库的指定路径）</p></li><li><p>内存最高的1G大小的空间就是<strong>内核空间</strong>了，主要分为ZONE_DMA、ZONE_NORMAL、ZONE_HIGHMEM三块区域，其中ZONE_NORMAL用于存放进程的PCB（进程控制块，存储进程相关信息）以及内部线程私有的栈空间信息等，而ZONE_MEM为高端内存，用于映射高地址物理内存（此处不详细展开）。</p><p>需要注意的是，内存上的内核空间是进程间共享的（进程间通过匿名管道通信），用户空间才是各个进程私有的，相互无法访问。</p></li></ol><p><img src="https://caimotu.top/Picgo/image-20250814174159721.png" alt="image-20250814174159721" style="zoom:67%"></p><p>以上就是一个进程的虚拟内存空间划分情况，接下来我们以一个简单的代码例子具体说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> gdata1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> gdata2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> gdata3;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> gdata4 = <span class="number">11</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> gdata5 = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> gdata6;</span><br><span class="line"><span class="comment">//以上六个变量都是全局变量，编译后会在可执行文件里的符号表里产符号映射，将变量名映射到运行时分配的内存地址。这些变量就称为数据，存放在虚拟内存的数据段里，具体的：gdata1和gdata4初始化不为零，存放在.data段；其余的初始化为零或未初始化，放在.bss段</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">12</span>;</span><br><span class="line">    <span class="comment">//在函数里声明的局部变量则不会在符号表里产生符号，这行代码编译后对应的是一个汇编指令:mov dword ptr[a],0Ch</span></span><br><span class="line">    <span class="comment">//表示将12这个值放到a这个变量在栈上的内存中（运行时指令本身放在.text段，12这个值被存放在栈上开辟好的4字节内存里）</span></span><br><span class="line">    <span class="comment">//PS:a这个字母并不会被CPU理解，实际的汇编指令里a应该是直接指向内存地址的一个指针，如ebp-4（ebp栈底是高地址），a只是编译器产生的方便程序员阅读的形式。因此只要程序运行到函数结束，栈上分配的线程对应的内存自动弹出销毁，进程就识别不到int a = 12这个信息了。</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="comment">//b,c与a同理，但是注意变量c没有初始化，所以是栈上的无效值，打印时会出现乱码。</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> e = <span class="number">13</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> g;</span><br><span class="line">    <span class="comment">//以上局部静态变量生命周期为整个程序运行过程，因次存放在静态数据段.data和.bss，但注意作用域还是局限于main函数</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; c &lt;&lt; <span class="string">"+"</span> &lt;&lt; g &lt;&lt; endl;<span class="comment">//打印结果是乱码+0，因为g会被加载器自动置零</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="汇编角度详解函数调用堆栈过程">汇编角度详解函数调用堆栈过程</h2><p>观察以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">"pch.cpp"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    temp = a + b;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ccloire.com">Loire</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ccloire.com/2025/08/07/C++%E5%90%88%E9%9B%86/C++%E5%88%9D%E7%BA%A7%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">https://ccloire.com/2025/08/07/C++%E5%90%88%E9%9B%86/C++%E5%88%9D%E7%BA%A7%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ccloire.com" target="_blank">Loire's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav id="pagination"><div class="pagination"></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/08/11/C++%E5%90%88%E9%9B%86/C&C++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%80%BB%E7%BB%93/" title="C&amp;C++基础语法--静态变量总结"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-11</div><div class="info-item-2">C&amp;C++基础语法--静态变量总结</div></div><div class="info-2"><div class="info-item-1">static 是一个非常关键的修饰符，但它的含义并不是单一的，而是根据其使用的位置而有所不同。它的核心作用可以归结为两点：改变变量的生命周期和改变变量或函数的链接属性（可见性）。 我们将分三个场景来讨论 static： 在函数内部使用（局部静态变量） 在函数外部使用（全局静态变量/函数） 在类（Class）内部使用（静态成员变量/函数） 在函数内部：局部静态变量 (Local Static Variable) 当 static 用于修饰函数内部的局部变量时，它彻底改变了这个变量的“生存方式”。 核心作用：延长生命周期。 一个普通的局部变量是存放在栈上的，它会随着函数的调用而被创建，随着函数的返回而被销毁。而一个局部静态变量则完全不同。 特性： 存储位置：它不再存储于栈上，而是和全局变量一样，存放在程序的静态存储区（.data 或 .bss 段）。 生命周期：它的生命周期是整个程序的运行期间，而不是函数的调用期间。从程序开始到结束，它都存在。 初始化：它只在程序第一次执行到其声明语句时被初始化，且仅初始化一次。后续再次调用该函数时，会跳过...</div></div></div></a><a class="pagination-related" href="/2025/08/12/C++%E5%90%88%E9%9B%86/C&C++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/" title="C&amp;C++基础语法-命令行参数"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-12</div><div class="info-item-2">C&amp;C++基础语法-命令行参数</div></div><div class="info-2"><div class="info-item-1">第一部分：什么是命令行参数 (Command-line Arguments)？ 命令行参数是在您从终端（命令行界面）启动一个程序时，跟在程序名称后面传递给该程序的一系列字符串。它们是一种让用户从外部控制程序行为、向程序传递初始数据的主要方式。 想象一下，程序本身是一个函数，而命令行参数就是您传递给这个函数的“参数”。 一个直观的例子： 当您在 Linux 终端输入这个命令时： ls -l /home ls：这是您要执行的程序名。 -l：这是传递给 ls 程序的第一个参数。它告诉 ls 程序使用“长列表格式”来显示文件。 /home：这是传递给 ls 程序的第二个参数。它告诉 ls 程序去列出 /home 目录下的内容。 通过 -l 和 /home 这两个参数，我们控制了 ls 程序的输出格式和目标路径，而无需修改 ls 程序本身的任何代码。 在 C/C++ 中如何接收命令行参数？ C/C++ 程序通过 main 函数的两个特殊形参来接收命令行参数：argc 和 argv。 C++ 123int main(int argc, cha...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">Loire</div><div class="author-info-description">记录CS学习路线以及各类经验分享</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/12/C++%E5%90%88%E9%9B%86/C&amp;C++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/" title="C&amp;C++基础语法-命令行参数">C&amp;C++基础语法-命令行参数</a><time datetime="2025-08-12T04:53:23.000Z" title="发表于 2025-08-12 12:53:23">2025-08-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/11/C++%E5%90%88%E9%9B%86/C&amp;C++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%80%BB%E7%BB%93/" title="C&amp;C++基础语法--静态变量总结">C&amp;C++基础语法--静态变量总结</a><time datetime="2025-08-11T06:24:03.000Z" title="发表于 2025-08-11 14:24:03">2025-08-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/07/C++%E5%90%88%E9%9B%86/C++%E5%88%9D%E7%BA%A7%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="C++初级——内存空间与编译原理">C++初级——内存空间与编译原理</a><time datetime="2025-08-07T14:13:10.000Z" title="发表于 2025-08-07 22:13:10">2025-08-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E8%A1%A8/" title="数据结构与算法---线性表">数据结构与算法---线性表</a><time datetime="2025-07-24T15:38:42.000Z" title="发表于 2025-07-24 23:38:42">2025-07-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E7%BB%AA%E8%AE%BA/" title="数据结构与算法---算法分析绪论">数据结构与算法---算法分析绪论</a><time datetime="2025-07-23T07:57:19.000Z" title="发表于 2025-07-23 15:57:19">2025-07-23</time></div></div></div></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size:1.3em;color:#99a1ac">数据结构与算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size:1.1em;color:#999">计算机网络</a> <a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size:1.1em;color:#999">生活</a> <a href="/tags/%E5%A4%9A%E6%A8%A1%E6%80%81%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/" style="font-size:1.1em;color:#999">多模态大模型论文学习</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" style="font-size:1.1em;color:#999">基础工具使用指南</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size:1.1em;color:#999">深度学习</a> <a href="/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" style="font-size:1.1em;color:#999">技术分享</a> <a href="/tags/C/" style="font-size:1.5em;color:#99a9bf">C++</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i> <span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025 </span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025 </span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025 </span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025 </span><span class="card-archive-list-count">4</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025 </span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025 </span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025 </span><span class="card-archive-list-count">1</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站信息</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">14</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总浏览量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastpushdate="2025-08-29T07:46:35.040Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2019 - 2025 By Loire</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(()=>{const t=()=>{if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typesetPromise();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"all"},chtml:{scale:1.1},options:{enableMenu:!0,renderActions:{findScript:[10,t=>{for(const e of document.querySelectorAll('script[type^="math/tex"]')){const n=!!e.type.match(/; *mode=display/),a=new t.options.MathItem(e.textContent,t.inputJax[0],n),d=document.createTextNode("");e.parentNode.replaceChild(d,e),a.start={node:d,delim:"",n:0},a.end={node:d,delim:"",n:0},t.math.push(a)}},""]}}};const t=document.createElement("script");t.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t)}};btf.addGlobalFn("encrypt",t,"mathjax"),window.pjax?t():window.addEventListener("load",t)})()</script><script>(()=>{const e=()=>{(()=>{const e=document.querySelectorAll("pre > code.mermaid");0!==e.length&&e.forEach(e=>{const t=document.createElement("pre");t.className="mermaid-src",t.hidden=!0,t.textContent=e.textContent;const n=document.createElement("div");n.className="mermaid-wrap",n.appendChild(t),e.parentNode.replaceWith(n)})})();const e=document.querySelectorAll("#article-container .mermaid-wrap");if(0===e.length)return;const t=()=>(e=>{window.loadMermaid=!0;const t="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";e.forEach((e,n)=>{const d=e.firstElementChild,a="mermaid-"+n,r=`%%{init:{ 'theme':'${t}'}}%%\n`+d.textContent,m=mermaid.render(a,r),o=e=>{d.insertAdjacentHTML("afterend",e)};"string"==typeof m?o(m):m.then(({svg:e})=>o(e))})})(e);btf.addGlobalFn("themeChange",t,"mermaid"),window.loadMermaid?t():btf.getScript("https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js").then(t)};btf.addGlobalFn("encrypt",e,"mermaid"),window.pjax?e():document.addEventListener("DOMContentLoaded",e)})()</script><script>(()=>{const t=(e,a)=>{"object"==typeof e&&null!==e&&Object.keys(e).forEach(r=>{const n=e[r];"object"==typeof n&&null!==n&&(n[a]?e[r]=n[a]:t(n,a))})},e=e=>{window.loadChartJS=!0,Array.from(e).forEach((e,a)=>{const r=e.firstElementChild,n=e.getAttribute("data-chartjs-id")||"chartjs-"+a,d=e.getAttribute("data-width"),o=document.getElementById(n);o&&o.parentNode.remove();const c=r.textContent,l=document.createElement("canvas");l.id=n;const s=document.createElement("div");s.className="chartjs-wrap",d&&(s.style.width=d),s.appendChild(l),r.insertAdjacentElement("afterend",s);const h=document.getElementById(n).getContext("2d"),i=JSON.parse(c),m="dark"===document.documentElement.getAttribute("data-theme")?"dark-mode":"light-mode";(t=>{"dark-mode"===t?(Chart.defaults.color="rgba(255, 255, 255, 0.8)",Chart.defaults.borderColor="rgba(255, 255, 255, 0.2)",Chart.defaults.scale.ticks.backdropColor="transparent"):(Chart.defaults.color="rgba(0, 0, 0, 0.8)",Chart.defaults.borderColor="rgba(0, 0, 0, 0.1)",Chart.defaults.scale.ticks.backdropColor="transparent")})(m),t(i,m),new Chart(h,i)})},a=()=>{const t=document.querySelectorAll("#article-container .chartjs-container");0!==t.length&&(window.loadChartJS?e(t):btf.getScript("https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js").then(()=>e(t)))};btf.addGlobalFn("themeChange",a,"chartjs"),btf.addGlobalFn("encrypt",a,"chartjs"),window.pjax?a():document.addEventListener("DOMContentLoaded",a)})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>